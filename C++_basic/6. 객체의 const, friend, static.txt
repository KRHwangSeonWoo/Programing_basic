[6. friend와 static 그리고 const 객체]




1. const 객체
const는 변경을 불가하도록 상수화 시키는 것이다.
const int a = 10;와 같이 객체도 상수화 시킬 수 있다.

const Student s1; 이런식으로 말이다.
또한 const로 선언된 객체는 const 멤버 함수만 호출이 가능하다.
변경 시킬 우려를 아예 차단한는 것이다.

[const 객체는 const 멤버 함수만을 호출할 수 있다]

*****************헷가리는 거 정리*****************
const 객체 vs const 멤버변수를 가지고 있는 객체

const 객체는 const 멤버함수만 호출이 가능하다 (const 객체는 초기화된 멤버변수를 가지지 않아도 컴파일러는 이경우를 허용한다는 결과가 나옴) 
const 멤버변수를 가지고 있는 객체는 만드시 선언과 동시에 초기화해야함 -> 헷가리면 멤버 이니셔라이즈의 const 멤버변수 초기화 참고

#######################################################
#include<iostream>

class Student {
public:
    int age;
    
    Student(int age) 
        :age(age){

    }

    void printAge()  {
        std::cout << age;
    }

    void printAge() const {
        std::cout <<"const" << age;
    }
};

int main() {
    const Student s1;
    std::cout << s1.age;

    s1.printAge(); 
    //const 10

    
}

#######################################################














2. friends 선언
A 클래스, B 클래스 두개가 있다고 가정할고 B클래스가 private 멤버변수를 가지고 있을 때
A클래스가 B클래스의 private 멤버변수에 접근할 수있도록 하는 것이다. (public도 당연히 접근 가능)

frined 선언 순서
A를 통해 B의 private 멤버변수를 확인하고자 할때
1. B 클래스에 A 클래스 friend 선언
2. A 클래스에서 B클래스 객체를 인자값으로 받고, B클래스 private 멤버변수 접근하는 함수 선언

*자기자신 class 메소드가 private 멤버변수에 접근하는 함수로 쓰는 건 당연히 되는거라 firend가 의미가 없음

#######################################################
#include<iostream>

class Girl {
private:
    int Girl_secret = 20;
    friend class Boy; // Boy 클래스를 friend로 선언
};


class Boy {
public:
    void girlPrint(Girl g1) {
        std::cout << g1.Girl_secret;
    }
};


int main() {
    Boy b1;
    Girl g1;
    b1.girlPrint(g1);

    return 0;
}
#######################################################










3. static

우선 C에서의 static 변수의 의미를 정리하자.
전역변수에 선언된 static의 의미
-> 선언된 파일 내에서만 참조를 허용하겠다는 의미
• 함수 내에 선언된 static의 의미
-> 한번만 초기화되고, 지역변수와 달리 함수를 빠져나가도 소멸되지 않는다.



#객체의 static 멤버변수는?
만약 해당 생성자를 호출하면 (객체가 생성되면) 몇번째 객체인지 출력하는 프로그램을 구현하려고 한다.
이때 중요한 로직은 아래와 같다.
-> 같은 클래스로 만들어진 객체가 같은 멤버변수를 바라보아야 한다. (생성자를 호출할 때마다 1씩 증가해야하기 때문)

이것이 어떻게 가능할까?? 객체는 기본적으로 자기 자신 객체에 할당된 메모리에 접근이 가능한데... 이걸 모두가 공유한다고?

결론을 말하지면 객체 내의 s1, s2, s3객체가 있다고 가정할 때 static 멤버변수는 각 객체에 저장된 것이아니다.
static 변수는 객체 외부에 있고, 해당 객체에 접근 권한을 준것뿐이다. 그렇기에 static 멤버변수에 대한 객체의 정보 공유가 가능했던 것이다.




##############################################################################################################
#include<iostream>

class Student {
    static int sequence;
public:
    Student() {
        sequence++;
        std::cout << sequence << "째 객체입니다. \n";
    }

    Student(const Student& s) {
        sequence++;
        std::cout << sequence << "째 객체입니다. (복사 생성자)\n";
    }
    
    Student StudentReturn(Student s) {
        sequence++;
        std::cout << sequence << "째 객체입니다. (복사 생성자)\n";
        
        return s;
    }


};

int Student::sequence = 0;

int main() {
    Student s1;
    //1째 객체입니다. (복사 생성자)
    Student s2;
    //2째 객체입니다. (복사 생성자)
    Student s3 = s1;
    //3째 객체입니다. (복사 생성자)
    Student s4 = s3.StudentReturn(s2); // -> 헷가리면 복사 생성자 다시 봐라
    //4째 객체입니다. (복사 생성자) -> Student s4(임시객체)
    //5째 객체입니다. (복사 생성자) -> 매개변수 시 객체 
    //6째 객체입니다. (복사 생성자) -> return (임시객체)
    return 0;
}
##############################################################################################################











