[배열]


1. 배열의 선언 및 초기화

아래의 방법처럼 배열을 선언할 수 있고, 인덱스는 0부터 시작한다.

 
*** a[void] 같은 경우 변수 선언시만 사용됨.
또한 배열은 배열 자체 즉 {1,2,3} 자체를 바꾸는 것은 허용되지 않고 요소를 통해 하나씩 바꾸는 건 가능하다.

***C 언어에서 배열의 초기화는 배열을 선언할 때만 가능합니다.
################################################################################################################
#include <stdio.h>

int main() {

	int a[5] = { 1,2,3,4,5 };
	
	int b[] = { 1,2,3,4,5 };

	int c[5];
	c[0] = 1;
	c[1] = 2;

	for (int i = 0; i < 5; i++) {
		printf("%d", b[i]);
		//12345
	}

}
################################################################################################################################


2. 배열의 메모리 구조

배열 이름은 실제로는 배열이 할당된 기억장소의 시작 주소이다.
예를 들어 int x[] = {1,2,3,4,5}로 배열을 선언할 때 x는 배열이 할당되어 있는 시작 주소이다.
위 예제는 int 형 5개의 정수를 선언하였으니 총 20바이트 메모리가 할당됨. (4X5)

배열 선언시 배열의 이름은 배열의 주소값을 가지고 있고, 배열[0]는 배열의 주소값이 가르키는 0번째 인덱스 값을 가르킨다.
################################################################################################################################
#include <stdio.h>

int main() {

	int a[] = { 1,2,3,4,5 };

	printf("배열의 이름 값, %u\n", a);
	printf("배열의 전체 크기, %d\n", sizeof(a));
	printf("배열a[0]의 크기 값, %u\n", sizeof(a[0]));
	/*
배열의 이름 값, 1171782296
배열의 전체 크기, 20
배열의 이름 값, 4
	*/


        int b = 3;
        printf("%p\n", b);


        int c[20] = { 1,2,3,4 };
        printf("%p\n", c);

        printf("%p\n", c[0])

        /*
        0000000000000003
        000000659CAFFAC0
        0000000000000001
        */

}
################################################################################################################################


배열 인수 전달
배열을 함수의 인수로 전달할 때는 배열 주소가 전달됨. 따라서 실제 배열 내용이 복사되어 전달되는 것은 아님
int add(int a[10])이나 int add(int a[])랑 똑같다는 소리 -> 즉 int a[1234]해도 무관함 쩌피 주소값만 전달해주니깐
################################################################################################################################
#include <stdio.h>

int add(int arr[100]) {
    int sum = 0;

    for (int i = 0; i < 3; i++) {
        sum = sum + arr[i];
       
    }

    printf("%d\n", sizeof(arr));
    //8
    /*
    따라서 sizeof(arr)가 8이 출력되는 이유는 아마도 64비트 아키텍처에서의 포인터 크기인 8바이트가 출력된 것입니다. 
    이것은 배열의 크기가 아니라 배열을 가리키는 포인터의 크기입니다. 
    */
    return sum;
}

int main() {
    int a[] = { 1, 2, 3, 4, 8 };
    printf("%d\n", add(a)); // 6
    printf("%d", sizeof(a)); //20
}

################################################################################################################################



배열 길이 전달
배열의 길이를 구하기 위해서는 배열 전체 size를 원소 하나의 size로 나누면 배열의 길이(원소 개수)가 나올것이다.
-> sizeof(arr[]) / sizeof(arr[0])
################################################################################################################################
#include <stdio.h>

int main() {

	int arr[] = { 1,2,3 };
	printf("%d", (sizeof(arr) / sizeof(arr[0])));
	//3


}
################################################################################################################################





배열 인수를 이용한 배열 원소 변경
배열 인수를 받아 함수에서 값을 변경하면 인수로 준 배열의 원소 값도 바뀜 -> 왜냐하면 값을 전달하는 것이 아니라 주소값을 전달하는 것이기때문
함수 내에서 값을 변경하지 못하게 하기 위해서는 const로 선언하는 것이 좋음
################################################################################################################################
#include <stdio.h>


void add(int arr[]) {

	arr[0] = 1000;

}

int main() {

	int a[] = { 1,2,3 };

	printf("%d", a[0]);
	//1

	add(a);
	
	printf("%d", a[0]);
	//100	
}
################################################################################################################################



3. 포인터 변수를 이용한 배열의 저장
문자열 상수를 받을 경우 const char*로 받아야 함.
################################################################################################################################
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <errno.h>
#include <string.h>

int main() {

	int* a;
	int b[3] = { 1,2,3 };
	a = b;
	printf("%d, %d\n", a[0], b[0]);

	a[0] = 100;
	printf("%d, %d\n", a[0], b[0]);

	//1, 1
	//100, 100


	int* g;
	const int h[3] = { 1,2,3 };
	//g = h; //에러 
	/*
	g가 h를 가리키는 것은 허용되지 않습니다. 이유는 h가 const 한정자로 선언되었기 때문입니다. 
	const 한정자가 붙은 변수나 배열은 값을 변경할 수 없는 불변성을 갖습니다. 
	따라서 g로 h를 가리키면 g를 통해 h의 내용을 변경하려는 시도가 되는데, 이것은 허용되지 않습니다.
	*/
	
	const int* r;
	const int j[3] = { 1,2,3 };
	r = j; 
	

	char* c;
	char d[5] = "hihi";
	c = d;
	printf("%s", c);
	//hihi

	const char* e;
	e = "hihi";


	char* f;
	//f = "hihi"; -> 에러

	

}
################################################################################################################################


4. 2차원 배열	
################################################################################################################################
#include <stdio.h>

int main() {

	int a[2][3] = { {1,2,3}, {4,5,6} };
	int b[2][3] = {1,2,3,4,5,6};
	//int b[][] = { {1,2,3}, {4,5,6} }; //-> 2차원 배열은 [void]로 생성할 경우 에러 발생함.

	printf("%d", sizeof(a) / sizeof(a[0][0]));
	//6

	printf("%d", b[0][3]);
	//4
}
################################################################################################################################
