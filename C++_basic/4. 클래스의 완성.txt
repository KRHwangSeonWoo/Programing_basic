[클래스의 완성]


1. 정보은닉
만약 객체의 매개 변수가 특정한 조건을 갖춰야 한다면 멤버 변수를 private로 하여 함수를 통해 초기화할 수 있도록 하는 것이 좋다.
main 함수에서 객체를 생성하고 직접 값을 할당하므로써 조건의 맞지 않는 값이 들어갈 수 있기 때문

즉, 멤버변수는 private로 선언하여 다른 곳에서 접근하지 못하도록 하고 오직 set 함수에서만 맴버변수 값을 할당하도록 하는 것임
#####################################################################################
#include<iostream>

class PublicAge{
public:
    int age;
};

class PricateAge{
private:
    int age;

public:
    void setAge(int age){
        if (age < 0) {
            std::cout << "잘못된 값";
            return;
        }
        else {
            age = age;
        }

    }

};

int main() {
    //잘못된 값이 들어갈수있음
    PublicAge age1;
    age1.age = -1;

    PricateAge age2;
    age2.setAge(1);
    age2.setAge(-1);
}
#####################################################################################










2. const 함수
객체의 맴버변수값을 변경하는 시도가 있으면 에러를 띄운다.
ex) 정보은닉에서 맴버변수의 값을 호출하는 get함수와 set 함수가 있으면 get 함수같은 경우 맴버변수의 값이 변경되면 안되기에 실수를 예방하고자 const 함수로 선언한다.
#const 함수 안에 또다른 함수를 호출할때 해당 함수도 const로 선언되어야 에러가 안뜸
#####################################################################################
#include<iostream>

class PricateAge{
private:
    int age;

public:
    void setAge (int age){
        if (age < 0) {
            std::cout << "잘못된 값";
            return;
        }
        else {
            age = age;
        }

    }
    void getAge() const {
        std::cout << age;
        //setAge(10); //에러 발생 -> const 함수 내에 실행되는 다른 함수도 const 선언이 되어야됨
    }

};

int main() {

}
#####################################################################################








3. 캡슐화
여러 클래스의 메소드를 한번에 불러오는 방법이다.
ex) 예를 들어 "게보린"의 경우 두통, 치통, 생리통 완화의 기능을 가지고있다.
만약 두통 치통 생리통이라는 클래스를 각각 만든 경우, main 함수에서 3개의 클래스의 객체를 전부 불러와서 "**통 완화~"를 출력해야한다.
하지만 캡슐화를 통해서는 해당 객체의 메소드를 하나의 객체의 메소드로 불러올수있다.

[캡슐화를 사용하지 않을 경우, 게보린을 먹을 때마다 3개 객체의 메소드를 각각 불러와야함 -> 불편] 
#####################################################################################
#include<iostream>

class Head {
public:
    void headOk() {
        std::cout << "두통 완화~";
    }
};

class Tooth {
public:
    void toothOk() {
        std::cout << "치통 완화~";
    }
};

class Sang {
public:
    void sangOk() {
        std::cout << "생리통 완화~";
    }
};
            void main() {
                Head head;
                head.headOk();
                Tooth tooth;
                tooth.toothOk();
                Sang sang;
                sang.sangOk();
            }
 //두통 완화~치통 완화~생리통 완화~
####################################################################################


[캡슐화를 사용할 경우 게보린 객체만 생성하여 다른 객체의 메소드 출력] 
####################################################################################
#include<iostream>

class Head {
public:
    void headOk() {
        std::cout << "두통 완화~";
    }
};

class Tooth {
public:
    void toothOk() {
        std::cout << "치통 완화~";
    }
};

class Sang {
public:
    void sangOk() {
        std::cout << "생리통 완화~";
    }
};

class Geborin {
private:
    Head head;
    Tooth tooth;
    Sang sang;

public:
    void getGeborin() {
        head.headOk();
        tooth.toothOk();
        sang.sangOk();
    }
};


void main() {
    Geborin ge;
    ge.getGeborin();
}
####################################################################################






4. 생성자
객체를 생성할 때 생성자를 통하여 객체의 멤버변수 값을 초기화하거나,
객체를 생성할 때 특정 로직을 수행할 수 있음
객체를 생성할때는 무조건!!!!!!!!!!!!!!!생성자가 호출된다.
근데 클래스안에 객체를 생성하지 않아도 default 생성자로 아래식으로 자동으로 생성된다.
------------------
Student() {
}
------------------
####################################################################################
#include<stdio.h>

class Student {
public: 
	int age;
	char name[10];

	//기본 생성자 -> 개발자가 생성자를 추가적으로 만들지 않아도
	//기본적으로 제공함
	Student() {

	}

	Student(int age, const char* name){
		age = age;
		name = name;
	}
};


int main() {

	//생성자를 이용하여 객체를 생성하는 3가지 방법
	Student s1(10, "hwang");
	Student *s2 = new Student;
	Student* s2 = new Student();

	s1.age = 20;
	s2->age = 10;
	
	Student s2(); //해당 코드는 함수의 "선언"으로 표현됨
	//생성자로 사용하기 위해서는 매개변수를 넣어야함
	//s2.age = 10;에러


}

Student S2() {

	Student s;
	return s;
}
####################################################################################











5. 멤버 이니셜라이즈드
위처럼 생성자 함수 내에서 멤버변수 초기화가 가능하지만, 멤버이니셜라이즈를 이용하여 멤버변수 초기화도 가능함
(간단히 값을 넣는 것이 가능, 무슨 strcpy같은 함수써서 초기화는 불가)
----------------------------------------------
Student(int _age, const char* _name)
		:age(_age)
	{
		strcpy(name, _name);
	};
----------------------------------------------

####################################################################################
#include<stdio.h>
#include <cstring>

class Student {
public:
	int age;
	char name[10];

	Student(int age, const char* name)
		:age(age)
	{
		strcpy(this->name, name);
	};

};


	int main() {
		Student s1(10, "hwang");


	}

####################################################################################



5-1) 멤버 이니셜라이즈의 const 멤버 변수 초기화
멤버 이니셜라이즈를 이용하여 const 멤버 변수를 초기화할 수 있다.
나머지는 다 불가능하다.


어떻게 가능했을까?
결론: const 변수의 선언 후 바로 초기화해야함. 즉 메모리 할당 후 바로 초기화가 되어야함
예를 들어)
const int a;
a = 10; //-> 에러 

const int a = 10; //에러 X

즉 int a라는 메모리를 할당한 후 바로 초기화해야한다는 것이다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
위와다르게 멤버이니셔라이즈는 생성자를 메모리할당과 동시에 정의된 멤버이니셔라이즈를 호출하여 멤버변수를 초기화한다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
멤버 초기화 리스트를 사용하지 않고 생성자를 호출하면 다음과 같은 프로세스가 발생합니다:

객체 생성: 해당 클래스의 객체가 생성됩니다. 이 과정에서 객체에 필요한 메모리가 할당됩니다.
멤버 초기화: 생성자 본문이 실행되기 전에, 클래스의 멤버 변수들은 해당 자료형의 기본값으로 초기화됩니다.
(값이 없으면 초기화 x하고 변수가 생성됨)
생성자 호출: 이후 생성자 본문에서 추가적인 초기화 작업을 수행할 수 있습니다.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
반면 멤버 초기화 리스트를 사용하여 생성자를 호출하면 다음과 같은 프로세스가 발생합니다:

객체 생성 및 메모리 할당: 해당 클래스의 객체가 생성됩니다. 이때 메모리가 할당되며, 멤버 변수들이 초기화되기를 기다립니다.
멤버 초기화 리스트 실행: 멤버 초기화 리스트에 지정된 초기화 값들이 사용되어 멤버 변수들이 초기화됩니다. 이 단계에서 이미 초기화된 멤버 변수들은 생성자 본문으로 넘어가기 전에 이미 초기화됩니다.
생성자 본문 실행: 생성자의 본문이 실행되어 추가적인 초기화 작업이 수행됩니다.
즉, 멤버 초기화 리스트를 사용하면 멤버 변수들이 생성자 본문에 진입하기 전에 이미 초기화되므로, 보다 효율적인 초기화가 이루어집니다. 이는 객체의 멤버 변수들이 생성자 본문에 진입하기 전에 이미 올바른 초기값을 가지고 있음을 보장하므로, 초기화 순서 및 예외 처리 등에서 잠재적인 문제를 방지할 수 있습니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

####################################################################################
#include<iostream>

class student {
public:
	const int age;

	/* 에러 발생
 	student(int age){
	age = age;
	}
	*/

	student(int age)
	:age(age){

	}
};

int main() {
	/*
	student* s1 = new student;
	student s2; -> 에러가 발생함
	*/
	
	student* s1 = new student(10); 
	student s2(10);


}
####################################################################################

