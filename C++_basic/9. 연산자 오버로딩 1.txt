[9. 연산자 오버로딩 1]






1. 이항 연산자 오버로딩, operator 함수
객체끼리 연산자를 사용해서 더하거나 뺄 경우 우리가 정의한 함수를 호출한다.
이게 무슨 말이냐면 예를 들어 Student s1, s2를 선언하고 
s3 = s1 + s2이 가능하다는 말이다.

본래 의미하는 +....는 숫자의 연산이다. 이는 +를 사용하면 특정 함수를 호출하는 방식이다.
마찬가지로 우리는 객체를 인자값을 넣어 사용하기에 객체를 인자값으로 받아 로직을 수행하는 함수로 대체되는것이기에 우리는 이것을 연산자 오버로딩이라고 부른다.



(1) 이항 연산자 operator, 즉 객체 s1, s2를 가지고 연산하는 것이다.


1) 클래스 연산자 오버로딩
Student s3 = s1 + s2 -> Student s3 = s1.operator+(s2)와 같은 의미이다.
즉, operator+라는 함수를 클래스에 정의해야지 사용 가능하다.
연산자 오버로딩은 operator +, - 등... 자신이 원하는 함수를 클래스에 정의하면 해당 객체의 클래스의 정의된 함수가 호출되는 방식이다.
(반드시 함수명은 operator + 연산자 식으로 정의해야 한다)
################################################################################
#include<iostream>

class Number {
public: 

	int number;

	Number(int number=1): number(number) {

	}
	/*
	
	*/
	Number operator + (const Number& num1) const {
		return Number(number + num1.number);
	}
};


int main() {

	Number num1;
	Number num2;

	Number num3 = num1 + num2;
	std::cout << num3.number;
}
################################################################################



2) 전역 함수 연산자 오버로딩
Student s3 = s1 + s2일 경우, 자동으로 operator+ 함수를 호출한다.
매개변수는 operator+(s1, s2) 형식으로 들어간다. 
################################################################################
#include<iostream>

class Number {
public: 

	int number;

	Number(int number=1): number(number) {

	}


};

Number operator + (const Number& num1, const Number& num2) {
	return Number( num1.number + num2.number);
}


int main() {

	Number num1;
	Number num2;

	Number num3 = num1 + num2;
	std::cout << num3.number;
}
################################################################################








(2) 단항 연산자 operator, 즉 객체 s1, 한개를 연산을 하는 것이다.
이것도 멤버 함수와 전역 함수 방식이 존재한다.

*멤버함수 방식: 매개변수를 받지 않는다.
*전역 함수 방식: 매개변수를 받는다. (자기 자신객체)
*후위연산인 경우 오버로딩할 매개변수에 int를 추가한다.




(1) 증감,감소 연산자 오버로딩
int 변수에 ++이나 --를 하면 1씩 증감한다.
하지만 객체에 ++와 --를 사용하게 한다면 어떻게하면될까?
마찬가지로 단항 연사자 오버로딩을 통해 진행하면 된다.



1)  전역함수를 통한 증감연산자 오버로딩
++(++num1) -> operator++(operator++(num1))

***아래 예제에서는 operator의 return이 참조자임
-> 만약에 매개변수를 비 const 형을 받고 참조자로 return하지 않고 임시객체로 return한다면? -> 에러가 발생함
(정확히는 ++num1에서 에러는 발생하지 않고, ++(++num1)에서 에러가 발생함
=>
즉, ++(++num1)을 풀어쓰면 operator++(operator++(num1))이다.

왜? 에러가 날까?
임시객체 특성 상 동작중인 라인 이후에는 메모리에 소멸됨
근데 [임시객체]를 [const가 없는 참조자형으로 매개변수]로써 받고, [return을 임시객체로 반환]하는 경우 모순이 발생함

-> 임시객체를 참조자 매개변수로 받는다? -> 임시객체 로직을 수행하는 줄의 작업이 끝나면 사라진다.
그렇기에 매개변수로 만약 임시객체를 참조자로 받을 경우에는 참조자로 return해야지 그 의미가 있기때문이다.
(아니 임시객체를 참조자로 받고 reuturn을 임시객체로 반환할 거면 뭐하러 참조자로 받아? 그냥 새로운 객체로 받지 (참조차X)
또, 그래 받는다고 쳐, 너가 또 코딩하다가 헷갈려서 값 바꿨다가 나중에 딴소리할바에는 차라리 const를 붙이던가)
 

operator는 참조객체를 인자값으로 받고 return은 임시객체 형태로 return한다. 즉 operator++(operator++(num1))에서 두번쨰 operator++를 수행할 때 임시객체가 참조객체 형태로 인자값이 받아지게 된다.
그렇기에 컴파일러는 에러를 띄운다. 해결하기 위해서는 아래의 방법을 따라하자

1) 인자값인 참조 객체를 const로 사용
2) return을 참조형으로 return

##############################################################################
#include<iostream>

class Number {
public:

    int number;

    Number(int number = 1) : number(number) {

    }


//////////////////클래스 연산자 오버로딩////////////////////////////
    Number& operator++() {
        this -> number += 1;
        return *this;
    }
};
////////////////////////////////////////////////////////////////////////

//////////////////전역함수 연산자 오버로딩////////////////////////////
/*

에러남
Number operator++(Number& num1) {
    num1.number += 1;
    return num1;
}

에러 X
Number& operator++(Number& num1) {
    num1.number += 1;
    return num1;
}

*/
//////////////////////////////////////////////////////////////////////////
int main() {
    Number num1;
    ++(++num1);
    std::cout << num1.number;
    //3
}
##############################################################################








2) 전위증가와 후위증가의 구분
++연산자와 --연산자는 피연산자의 위치에 따라 의미가 달라진다.

ex) 전위증가
int b= 1;
int a = ++b; -> a에 b의 값을 넣고 b는 1 증가

ex) 후위증가
int b= 1;
int a = ++b; -> b에 1을 증가시키고 a에 값 대입


*** 단항연산자 연산자 오버라이딩의 전위증가와 후위증가 구분 방법
-> 연산자 오버라이딩할 매개변수에 "int"를 추가 (해당 int는 후위증가를 나타내는 방법이며 더이상의 매개변수의 의미는 없다)


***후위연산자 같은 경우  호출한 객체를 복사생성자를 이용하여 복사하여 생성한 객체를 임시적으로 생성한 후 실제로 호출한 객체의 num을 +1하고 임시로 만든 객체를 return한다.


***후위 연산자에 return을 const로 할경우 중복된 연산이 불가하다.
-> return의 형식이 const이기에 return되는 객체의 값을 수정하면 에러가 발생함 그렇기에 중복 연산이 불가하다.

############################################################
#include <iostream>

class Num {
public:
    int num;

    Num() : num(0) {}

    const Num& operator++() {
        this->num += 1;
        return *this;
    }

    const Num operator++(int) {
        Num temp(*this);
        this->num += 1;
        return temp;
    }
};

int main() {
    Num num1;
    Num num2;
    Num num3;

    num1 = ++num2;
    std::cout << num1.num;  // 출력: 1
    //(++num2).num = 20; 에러
  

    num1 = num3++;
    std::cout << num1.num;  // 출력: 0
    //(num2++)++ -> 에러


}
############################################################









3) 다른 자료형끼리의 연산
다른 자료형끼리의 연산자 오버라이딩을 통한 호출에서는 순서가 중요하다.
Num num2 = num1 + 20; 인 경우 num1.operator+(20)로 호출되기에 순서가 바뀌면
20.operator+(num1)로 해석되어 문제가 발생된다.
############################################################
#include<iostream>

class Num {
public:
	int num;
	
	Num() :num(0) {

	}

	Num& operator + (int num2) {
		this->num += num2;
		return *this;
	}
};


int main() {

	Num num1;
	Num num2 = num1 + 20;
	//Num num3 = 20 + num1; -> 에러
}
############################################################


-> 위 예제에서 순서를 굳이 바꾸고 싶다면 전역함수 연산자 오버라이딩으로 바꿔서 사용하면 된다.
 
############################################################
#include<iostream>

class Num {
public:
	int num;
	
	Num() :num(0) {

	}
};

Num& operator + (int num2, Num& num) {
	num.num += num2;
	return num;
}

int main() {

	Num num1;
	//Num num2 = num1 + 20;
	Num num3 = 20 + num1;
}
############################################################




