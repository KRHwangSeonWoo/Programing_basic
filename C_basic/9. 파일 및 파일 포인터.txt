[파일 및 파일 포인터]


1. 파일
파일은 모든데이터를 연속된 바이트 형태로 저장한다.

*파일의 종류
텍스트 파일: 사람이 읽을 수 있는 문자들을 저장하고 있는 파일 (C 소스파일, 메모장...)
이진파일: 문자가 아니라 바이너리(이진) 데이터가 저장되어 있는 파일로 사람이 읽을 수는 없지만 프로그램에서 읽을 수있는 파일 (실행 파일, 사운드 파일, 이미지 파일)

*추가적으로 stdio.h에는 이미 열려있는 3개의 파일(입출력 장치)에대한 FILE 포인터가 정의됨

stdin -> 표준 입력 -> 키보드
stdout -> 표준 출력 -> 모니터
stderr -> 표준 오류 -> 모니터


(1) 파일 열기, 닫기

1) 파일 열기
C에서 파일을 열기 위해서는 fopen으로 파일을 연다.

File fopen(const char *filename, const char *mode);

모드는 r, w, a가 있고, r은 읽기, w는 안에 내용 비우고 쓰기, a는 안에 내용 냅두고 추가로 쓰기이다.
r+, w+, a+가 있는데 일단 읽기와 쓰기는 dafault로 되고 각 특색은 유지된다고 이해하면 된다. (a는 추가 w는 기존내용지우고 쓰기)
파일이 없을 때는 w, a는 새로생성되고 r은 NULL을 반환
###################################################################################################################################################################################################
#include <stdio.h>

int main() {
	
	FILE* ptr;

	ptr = fopen("C:\Windows.old","r");

	fclose(ptr);


}
####################################################################################################################################################################################################



2) 파일 닫기
int fclose(FILE *fp);
-> 닫기에 성공하면 0, 실패하면 -1 반환
###################################################################################################################################################################################################
#include <stdio.h>

int main() {
	
	FILE* ptr;

	ptr = fopen("C:\Windows.old","r");

	fclose(ptr);


}
####################################################################################################################################################################################################















2. 텍스트 파일 입출력

표준 입출력 함수 vs 파일 입출력 함수

표준 입출력 함수		파일 입출력 함수		기능
getchar()			fgetc(), get()		문자 단위로 입력하는 함수
putchar()			fput(), putc()		문자 단위로 출력하는 함수
gets()			fget()			줄 단위로 입력하는 함수
puts()			fputs()			줄 단위로 출력하는 함수
scanf()			fscanf()			포맷에 따라 자료를 입력하는 함수
printf()			fprintf()			포맷에 따라 자료를 출력하는 함수




(1) 문자 단위 입출력

문자단위 입력: int fgetc(FILE *fp); or int getc(FILE *fp);
-> fp가 가르키는 파일에서 한 문자를 읽어서 반환, 파일 끝에 도달하면 EOF(-1)을 반환
문자 단위 출력: int fputc(int c, FILE *fp); or int putc(int c, FILE *fp);
fp가 가르키는 파일에 한문자를 출력하여 출력하는 문자를 반환, 출력 오류시 EOF(-1) 반환


1) 키보드로부터 받은 입력을 모니터에 출력하는 프로그램
##################################################################################################################################################################################################################
#include <stdio.h>

int main() {
	

	int c;
	c = fgetc(stdin); //stdin -> 표준 입력 -> 키보드
	//키보드로 부터 문자를 읽어 c에 저장

	while (c != EOF) { //파일이 끝이 아닌 동안 반복
		fputc(c, stdout); //표준 출력에 문자 c 출력
		c = fgetc(stdin); //키보드로부터 문자를 읽어 c에 저장
	}

}
###################################################################################################################################################################################################################





2) 키보드에서 문자를 입력받아 파일에 저장하는 프로그램
###################################################################################################################################################################################################################
#include <stdio.h>

int main(int argc, char* argv[]) {
    if (argc < 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    FILE* fp;
    int c;

    if (fopen_s(&fp, argv[1], "w") != 0) {
        perror("Error opening file");
        return 1;
    }

    while ((c = getc(stdin)) != EOF) {
        putc(c, fp);
    }

    fclose(fp);
    printf("%s 파일에 저장완료\n", argv[1]);

    return 0;
}
###################################################################################################################################################################################################################





3) 파일 복사 프로그램 -> 해당 예제는 프로그램 파일을 클릭하여 실행해야 됐었음, 즉 파일이 있는 디렉토리에 실행해야 함
###################################################################################################################################################################################################################
#include <stdio.h>

int main() {

	char c;
	FILE* fp1, * fp2;

	errno_t err1 = fopen_s(&fp1, "hi.txt", "r");
	if (err1 != 0 || fp1 == NULL) {
		printf("파일 %s 열기 오류");
		return 1;
	}

	errno_t err2 = fopen_s(&fp2, "bye.txt", "w");
	if (err2 != 0 || fp2 == NULL) {
		printf("파일 %s 열기 오류:\n");
		fclose(fp1);
		return 1;
	}

	while ((c = fgetc(fp1)) != EOF) {
		fputc(c, fp2);
	}

	fclose(fp1);
	fclose(fp2);

	return 0;
}
###################################################################################################################################################################################################################






4) 기타 파일 관련 함수

int feof(FILE *fp): fp가 가르키는 파일이 파일 끝에 도달했으면 0이 아닌 값을 반환하고, 그렇지 않으면 0을 반환한다.
int ungetc(int c, FILE *p): c에 저장된 문자를 입력 스트림에 반납한다. 마치 문자를 읽지 않은 것처럼 파일 위치 지정자를 1 감소시킴
int fflush(FILE *fp): 아직 기록되지 않고 버퍼에 남아있는 데이터를 fp가 지정한 출력 파일에 보낸다. 버퍼 비우기 기능을 수행하는 함수













(2) 줄 단위 입출력
"문자열.txt"에 있는 gets()함수 키보드로 한줄 씩 읽을 수  있듯이, fgets()함수를 이용하여 파일 안에 있는 내용을 한줄 씩 읽을 수 있다.

*유의 사항
gets() 함수는 입력을 끝낼 때 '\n'(엔터)를 무시하여 문자열에 포함시키지 않지만 fgets() 함수는 '\n'을 읽어서 문자열에 포함시킨다. fgets() 함수를 사용하여 안전하게 텍스트 입력을 처리하는 것이 좋다


문자 단위 입력: char* fgets(char *s, int n, FILE *fp): 파일로부터 한 줄을 읽어서 문자열 s에 저장하고, s를 반환함. 줄바꿈 문자나 EOF를 만날 때까지 최대 n-1개의 문자를 읽고 읽어온 데이터의 끝에는 NULL 문자를 붙여줌
파일을 읽는 중에 파일 끝에 도달하거나 오류가 발생하면 NULL 포인터를 반환한다.

문자 단위 출력: char fputs(const char *s, FILE *fp): 문자열 s를 포인터 fp가 가르키는 파일에 출력한다. 문자열 끝을 나타내는 NULL 문자는 출력하지 않는다. 
성공적으로 출력한 경우에는 출력한 바이트 수를 반환한다. 출력할 때 오류가발생하면 NULL을 반환
######################################################################################################################################################################################################
#include <stdio.h>

#define MAXLINE 80

int main(int argc, char* argv[]) {
	FILE* fp;
	int line = 0;
	char buffer[MAXLINE];

	if (argc != 2) {
		fprintf(stderr, "사용법: %s 파일이름\n", argv[0]);
		return 1;
	}

	fopen_s(&fp, argv[1], "r");
	if (fp == NULL) {
		fprintf(stderr, "파일 열기 오류\n");
		return 2;
	}

	while (fgets(buffer, MAXLINE, fp) != NULL) {
		line++;
		printf("%3d %s", line, buffer);
	}

	fclose(fp);

	return 0;
}
######################################################################################################################################################################################################
실행 결과:   
  1 1
  2 2
  3 3
  4 4
  5 5
  6 6
  7 7
  8 8


######################################################################################################################################################################################################
#include <stdio.h>

int main() {
    FILE *file;
    const char *text = "Hello, fputs example!";
    
    // 파일을 쓰기 모드로 열기 (파일이 이미 존재할 경우 덮어쓰기)
    file = fopen("example.txt", "w");
    
    if (file == NULL) {
        perror("파일 열기 실패");
        return 1;
    }
    
    // 문자열을 파일에 쓰기
    if (fputs(text, file) == EOF) {
        perror("파일에 문자열 쓰기 실패");
        return 1;
    }
    
    // 파일 닫기
    fclose(file);
    
    printf("파일에 문자열을 성공적으로 썼습니다.\n");
    
    return 0;
}
######################################################################################################################################################################################################












(3) 포맷 입출력
printf, scanf는 stdin(키보드)로부터 입력을 받는 방면 fprintf, fscanf는 파일로부터 입출력을 수행한다.
######################################################################################################################################################################################################
int fprintf(FILE *fp, const char *format,...);
-> ex) fscanf(fp2, "%d", i); -> fprintf 함수의 첫번째 인수 fp는 출력할 때 파일에 대한 FILE의 포인터이고, 두번째는 printf 함수와 동일
int fscanf(FILE *fp, const char *format, ...);
-> ex) fprintf(fp2, "%d, &i); -> fscanf 함수의 첫번째 인수 fp는 출력할 때 파일에 대한 FILE의 포인터이고, 두번째는 scanf 함수와 동일

#include <stdio.h>

int main() {
    char string[100]; // 문자열을 저장할 배열 선언

    FILE* fp;
    fopen_s(&fp, "hi.txt", "r");

    if (fp == NULL) {
        fprintf(stderr, "파일 열기 오류\n");
        return 1;
    }

    fscanf_s(fp, "%s", string, sizeof(string)); // 문자열 읽기

    fclose(fp); // 파일 닫기

    fopen_s(&fp, "output.txt", "w");
    if (fp == NULL) {
        fprintf(stderr, "파일 열기 오류\n");
        return 2;
    }

    fprintf(fp, "%s", string); // 문자열 쓰기

    fclose(fp); // 파일 닫기

    return 0;
}
######################################################################################################################################################################################################


























2. 이진 파일
이진파일은 실행파일, 사운드 파일 등을 의미한다.
이진파일으로부터 입출력을 수행하기 위해서는 이진 입출력모드로 fopen()해야 한다.

모드는 r, w, a가 있고, r은 읽기, w는 안에 내용 비우고 쓰기, a는 안에 내용 냅두고 추가로 쓰기이다.
r+, w+, a+가 있는데 일단 읽기와 쓰기는 dafault로 되고 각 특색은 유지된다고 이해하면 된다. (a는 추가 w는 기존내용지우고 쓰기)
파일이 없을 때는 w, a는 새로생성되고 r은 NULL을 반환
**여기서 b를 함께 사용하면 됨.
-> 예를 들어 rb, wb..

(1) 블록단위 입출력
이진 파일으로부터 입출력하기 위해서는 일정한 크기의 데이터를 읽거나 쓸 수 있어야 함.
fread()와 fwrite()함수는 여러개의 블록을 파일에서 읽거나 파일에 쓰기 위한 함수이다. 
(꼭 이진 파일에 사용하지 않아도됨, text파일도 사용가능)

int fread(void *buf, int size, int n, FILE *fp);
fread 함수는 fp가 가르키는 파일에서 size 크기의 연속된 바이트를 n개 읽어서 버퍼 buf에 저장한다.
읽어온 블록의 개수를 반환한다.

int fwrite(const void *buf, int size, int n, FILE *fp);
fwrite 함수는 파일 포인터 fp가 지정한 파일에 버퍼 buf에 저장되어 있는 size 크기의 블록을 n개 기록한다.
성공적으로 출력한 블록 개수를 반환한다.

이 함수드을 사용할 때 읽거나 슬 내용을 저장할 버퍼는 임의의 자료형에 대한 포인터이며, fread() 함수를 사용할 때 버퍼(buf)의 크기는 읽어 올 데이터의 크기와 같거나 커야한다는 점을
주의해야 한다.

#####################################################################################################################################################################
/*이진 파일로 저장*/
#include <stdio.h>
#pragma warning(disable: 4996) // scanf_s 함수와 관련된 경고를 무시
#include <string.h> // strcpy 함수를 사용하기 위해 필요한 헤더 파일

struct student {
    int age;
    char name[30];
};

int main(int argc, char* argv[]) {

    if (argc != 2) {
        printf("사용법: %s 파일이름\n", argv[0]);
        return 1;
    }

    FILE* fp;

    errno_t err;

    // 파일을 열고 오류 처리
    err = fopen_s(&fp, argv[1], "wb");
    if (err != 0) {
        printf("파일 열기 실패. 오류 코드: %d\n", err);
        return 1;
    }

    struct student s1;
    
    s1.age = 20;
    strcpy(s1.name, "hwang");
    fwrite(&s1, sizeof(s1), 1, fp);
    



    // 파일을 닫습니다.
    fclose(fp);

    return 0;
}

#####################################################################################################################################################################







#####################################################################################################################################################################
/*이진 파일을 출력*/
#include <stdio.h>
#pragma warning(disable: 4996) // scanf_s 함수와 관련된 경고를 무시
#include <string.h> // strcpy 함수를 사용하기 위해 필요한 헤더 파일

struct student {
    int age;
    char name[30];
};

int main(int argc, char* argv[]) {

    if (argc != 2) {
        printf("사용법: %s 파일이름\n", argv[0]);
        return 1;
    }

    FILE* fp;

    errno_t err;

    err = fopen_s(&fp, argv[1], "rb");
    if (err != 0) {
        printf("파일 열기 실패. 오류 코드: %d\n", err);
        return 2;
    }

    struct student s1;
    
    
    while (fread(&s1, sizeof(s1), 1, fp) > 0) {
        printf("%d %s", s1.age, s1.name);
    }

    fclose(fp);



    // 파일을 닫습니다.
    fclose(fp);

    return 0;
}

/*
C:\Users\pc-1\source\repos\test\x64\Debug>test bye3
20 hwang
*/
#####################################################################################################################################################################









3. 임의 접근 파일 처리
지금까지는 처음부터 끝까지 순차적으로 진행하면서 데이터를 저장하거나 읽었다,.
읽어들이는 바이트 수만큼 자동적으로 증가하고, 파일의 끝을 만나면 동작을 멈추는 방식이었다.
그러나 파일의 크기가 매우 크고 원하는 데이터가 파일 중간 중간에 있을 때 이러한 순차 접근 방법은 매우 불편하다.
그렇기에 사용자가 원하는 자료가 있는 곳을 직접적으로 임의 접근할 수 있는 방법이 필요함.
그것이 fseek(), ftell()이다.

***함수들
fseek(FILE *fp, long offset, int mode)
FILE 포인터 fp가 가르키는 파일의 위치를 모드가 나타내는 시준점을 기준으로 오프셋만큼 옮긴다.
rewind(FILE *fp)
파일 위치를 파일 시작점에 위치시킨으로써 처음부터 다시 읽을 수 있게 한다.
ftell(FILE *fp)
FILE 포인터 fp가 가르키는 파일의 현재 파일 위치를 반환한다.



(1) fseek, ftell을 이용한 동적할당
위에 예제는 char a[10]이런 식으로 고정된 크기가 있다. 파일은 계속해서 고정된것이 아닌 더쓸수도 있고 더 없을 수도있는데 위 예제는 매우 비효율적이다.
아래 방법을 사용해서 동적으로 할당 받자! -> cmd에서 정상 작동
######################################################################################################################################################################################################
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE* fp;
    fopen_s(&fp, "bye.txt", "r"); // "hi.txt" 파일을 읽기 모드로 열기
    if (fp == NULL) { // 파일 열기에 실패한 경우
        fprintf(stderr, "파일 열기 오류\n"); // 오류 메시지 출력
        return 1; // 프로그램 종료
    }
    /*
fseek 함수란?
fp: 파일 포인터입니다.
0: 이동할 바이트 수를 0으로 설정합니다. 이는 위치를 변경하지 않는다는 것을 의미합니다.
SEEK_END: 파일의 끝 부분을 기준으로 이동합니다.
SEEK_SET: 파일 포인터를 파일의 처음으로 이동
    */
    fseek(fp, 0, SEEK_END); // 파일 포인터를 파일의 끝으로 이동
    long fileSize = ftell(fp); // 파일 포인터의 위치 (파일 크기) 저장
    fseek(fp, 0, SEEK_SET); // 파일 포인터를 파일의 처음으로 이동

    char* fileContent = (char*)malloc(fileSize + 1); // 파일 크기만큼 메모리 할당, 1은 NULL 문자 삽입을 위한것
    if (fileContent == NULL) { // 메모리 할당에 실패한 경우
        fprintf(stderr, "메모리 할당 오류\n"); // 오류 메시지 출력
        fclose(fp); // 파일 닫기
        return 2; // 프로그램 종료
    }

    fread(fileContent, 1, fileSize, fp); // 파일 내용을 메모리로 읽기
    /*
 fileContent: 파일로부터 읽어온 데이터를 저장할 메모리 버퍼의 포인터입니다. 이는 char* 타입인 fileContent 포인터입니다.
1: 각 데이터 항목의 크기를 1바이트로 지정합니다 -> 문자이기 때문에? (1byte)
fileSize: 읽을 데이터 항목의 개수를 fileSize로 지정합니다. 이는 파일의 크기입니다.
fp: 파일로부터 데이터를 읽어올 파일 포인터입니다.


    */

    fileContent[fileSize] = '\0'; // 문자열 끝에 널 종료 문자 추가

    fclose(fp); // 파일 닫기

    printf("파일 내용:\n%s\n", fileContent); // 파일 내용 출력
     free(fileContent); // 할당한 메모리 해제

    return 0; // 프로그램 종료
}
######################################################################################################################################################################################################




