12. 템플릿 1









1.  함수 템플릿이란
매개변수와 return 등을 특정 자료형을 적시하지 않은 함수
-> 호출 시 자료형을 기재해야 한다.

***typename와 class 둘중 하나 사용하면 됨
##########################################
int add(int num1, int num2){
return num1 + num2;
}

->

template <typename T>
T Add(T num1, T num2){
return num1 + num2;
}
##########################################



[예제]
##########################################
#include<iostream>

template <typename T>
T Add(T num1, T num2) {
	return num1 + num2;
}

void main() {
	std::cout << Add<int>(20, 30.3);
	std::cout << Add<float>(20, 30.3);
	//50
	//50.3
}
##########################################


[Type을 명시하지 않은 경우, 컴파일러가 자동으로 형을 판단]
- 인자 TYPE 2개를 T로 선언하고 인자 두개가 일치하지 않을 경우 error 발생
##########################################
#include<iostream>

template <typename T>
T Add(T num1, T num2) {
	return num1 + num2;
}

void main() {
	std::cout << Add(29.5, 30.3);
	//std::cout << Add(29, 30.3); -> error

}
##########################################





2. 함수 템플릿과 템플릿함수

1) 함수 템플릿
앞서 보인 정의를 함수 템플릿이라고 한다.
***************************************
template <typename T>
T Add(T num1, T num2){
return num1 + num2
}
***************************************


2) 템플릿 함수
함수 템플릿으로 컴파일러가 만들어 내는 다음 유형의 함수를 템플릿함수라고 한다.

***************************************
template <typename T>
T Add(T num1, T num2){
return num1 + num2
}

void main(){

Add<int>(10,30);
Add(10.1,30.3);
}
***************************************

-> 실행 시 컴파일러가 만들어낸 함수

**************************************
int Add<int> (int num1, int num2){
return num1 + num2
}

float Add<float> (float num1, float num2){
return num1 + num2
}
**************************************





3. 둘 이상의 템플릿
아래와 같이 둘이 이상의 자료 템플릿을 선언하여 사용이 가능하다.
##########################################
#include<iostream>

template <typename T1, typename T2>
T2 Add(T1 num1, T2 num2) {
	return num1 + num2;
}

void main() {
	std::cout << Add(29, 30.3);
	std::cout << Add(29.3, 30);

	std::cout << Add<int, float>(29, 30.3);

}
##########################################










4. 함수 템플릿의 특수화
자료형에 따라서 로직이 달라지기에 특정 자료형이 올 경우, 다른 로직을 수행해야한다.
ex) 두 개의 자료형을 더하는 로직을 짜려하는데 int인 경우 가능하지만 char *인 경우 단순히 +를 사용해서는 안된다.
즉 char * 인 경우 따로 그 자료형에 맞는 로직을 정의해야 한다.
int + int (0)
char * + char * (X)

****************************
template<>
int Add(char* a, char* b) {
    strcat_s(a, 11, b);
    return 1;

}
-> 해당 특수화된 함수 템플릿을 만들기 위해서는 아래의 조건을 충족해야한다.
1) 함수 템플릿중 return이 int인 경우
2) 특수화 함수 템플릿의 매개변수가 함수 템플릿에 대입했을 때 문제가 없어야함
- 매개변수 2개의 T를 받는 함수 템플릿이면, 특수화 템플릿에서는 매개변수가 동일한 타입으로 받아야함
- 매개변수 2개 중 하나만 T를 받는 함수 템플릿이면, 특수화에서는 나머지 매개변수 타입이 일치해야함

#또한 호출 시 Add(a, b) or Add<char *>(a,b) 식으로 호출이 가능하다.
전자는 컴파일러가 자동적으로 T의 자료형을 인식하는 거고, 후자는 프로그래머가 명시적으로 T의 자료형을 알려주는 것이다.
****************************


####################################################################################
#include<iostream>
#include<cstring> 

/*
template <typename T>
T Add(T num1, T num2) {
    return num1 + num2;
}
//2개의 매개변수가 동일한 경우 호출됨

*/


template <typename T>
int Add(T num1, T num2) {
    return num1 + num2;
}
//2개의 매개변수가 동일한 경우 호출됨



template<>
int Add(char* a,  char* b) {
    strcat_s(a, 11, b);
    return 1;

}
//2개의 매개변수가 char *일 경우에 호출됨
//또한 위에 int Add(T num1, T num2)가 정의되지 않을 경우 에러가 발생함
//특수화 함수 템플릿은 기본 함수 템플릿에 정의된 형태와 동일해야함 (return 값, 매개변수 자료형(만약에 매개변수 2개가 T인 경우, 두 매개변수는 동일해야함))


int main() {
    char a[11] = "hello";
    char b[11] = "world";

    std::cout << Add<char *>(a, b) << std::endl;
    std::cout << Add(a, b) << std::endl;
    return 0;
}
####################################################################################
