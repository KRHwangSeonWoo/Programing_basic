1. const 의미

***const (*ptr3 상수화 즉 &a가 가르키는 값 상수화) int * const(&a 주소를 상수화) ptr3 = &a;
const로 지정된 상수는 (문자열 상수, 정수형 상수 등 데이터 영역 중 정적 메모리 영역에 할당된다 (사라지지 않음))

또한 const를 사용하기 위해서는 선언과 동시에 초기화해야 한다.

#############################################################################
#include<iostream>

int main() {

    const int a = 10;
    // a = 20; // 에러: const 변수의 값을 수정할 수 없습니다.

    int b = 20;
    int c = 30;

    const int* ptr1 = &b;
    ptr1 = &c; // 가능: ptr1은 상수 정수를 가리키는 포인터이므로 다른 상수 정수를 가리키도록 할 수 있습니다.
    //*ptr1 = 3;

    int* const ptr2 = &b;
    //ptr2 = &c;
    *ptr2 = 30;



    const int* const ptr3 = &a;
    //ptr2 = &a; // 에러: const 포인터를 수정할 수 없습니다.
    //*ptr2 = 3; //에러

}
#############################################################################




2. 메모리 

데이터: 전역변수가 저장되는 영역
스택: 지역 변수, 매개변수가 저장되는 영역
힙: malloc 함수 호출에 의해 프로그램이 실행되는 과정에서 동적으로 할당이 이루어지는 영역

malloc & free: malloc으로 할당된 메모리는 free함수 호출을 통해 소멸하지 않으면 해제되지 않음



3. call by value, call by reference

#############################################################################
#include<iostream>

void CallByValue(int a, int b) {
	int c = b;
	a = b;
	b = c;
}

void CallbyRefer(int* a, int* b) {
	int temp = *b;
	*b = *a;
	*a = temp;


}

int main() {
	int a = 1, b = 2;
	CallByValue(a, b);
	std::cout << a << "  " << b << std::endl;
	
	CallbyRefer(&a, &b);
	std::cout << a << "  " << b << std::endl;

}
#############################################################################
1  2
2  1 



4. bool의 의미
bool은 1byte 데이터이다. 0, 1만을 표현함
0은 False, 1은 True를 표현함
0 자체가 False, 1이 True를 의미하는 것이 아니라 표현하는 것임
#############################################################################
#include<iostream>

int main() {

	std::cout << true << std::endl;
	std::cout << false << std::endl;
	std::cout << sizeof(true) << std::endl;
	std::cout << sizeof(false) << std::endl;
}
#############################################################################



5. 참조자의 이해

우선 변수는 메모리 공간에 붙여진 "이름(별칭)"임 
이 이름을 통해 같은 메모리를 바라보는 또 다른 별칭?를 선언할 수 있음
이때 참조자를 선언을 통해 이를 가능하게 할 수 있음

int &num = num1; 이런식으로 가능함

*** &의 두가지 의미
1. 선언된 변수의 & (int * ptr = &num): 해당 변수의 주소값 반환
2. 선언되는 변수의 &(int &num = num1): 변수 num1에 대한 참조자 num을 선언해라

그럼 변수와 참조자는 같은 걸까?
변수로 봐도 무리는 없지만 C++에서는 분리해서 보고있음
즉 변수를 참조하여 생성된 참조자는 참조라라는 별도의 이름을 가진다.


#############################################################################
#include<iostream>

int main() {

	int num1 = 10;
	int &num = num1;
	std::cout << num1 << "     " << num << std::endl;

}
#############################################################################
10     10




(1) 참조자는 별칭이다.
C++에서는 참조자를 변수에 별칭을 지어주는 것이라고 봄
그렇다!!! 참조자는 변수의 또 다른 이름을 지어준다고 보자!
무조건!!! 선언과 동시에 변수를 참조하도록 해야한다.




(2) 참조자를 응용
참조자를 사용할 때는 함수가 큰 위치를 차지함 (매개변수를 넘길떄)
그렇기에 참조자를 이용한 call-by-refernce 예제를 설명하려 한다.
-> 예제에서 int &a는 선언과 동시에 변수를 참조해야하는데 예제는 아니네요 왜그렇죠?
매개변수의 기본 역할 자체는 함수의 호출과 동시에 인자로 초기한다. 그렇기에 이는 문제가 없다.
(디폴트 함수 제외)
#############################################################################
#include<iostream>

void callByRefer(int &a, int &b) {
	int temp = a;
	a = b;
	b = temp;
}

int main() {
	int a = 10, b = 20;
	callByRefer(a, b);
	std::cout << a << "     " << b << std::endl;


}
#############################################################################


(3) 참조자를 이용한 call by refernce의 문제점과 해결방안
결론적으로 C++ 개발자는 함수를 만들 때 참조자를 매개변수로 이용하지 않으려한다.
왜냐하면 예를 들어 아래와 같은 로직이 있다고 가정해보겠다.

int num = 24;
HappyFunc(num);

여기서 HappyFunc 함수에 들어가서 num의 값이 변경하지 않을 것이라는 보장이 있는가?
C에서는 참조자가 없기에 24가 출력되지만, C++에서는 보장할 수 없다.
즉 HappyFunc 함수까지 들어가서 인자를 int &a 이런식으로 받는지 확인해야 하는 것이다.

해당 문제를 해결하기 위해서는 함수를 선언할 때 const를 붙이면 된다.
void HappyFunc(const int &a); -> 이런식으로
그렇다면 HappyFunc 함수 내에서 a의 값을 변경하려고 할 때 에러를 띄울 것이다.



(4) 반환형이 참조자일 경우
기본형 -> int &fun(int &a)

예제) 
#int &fun(int &a)
int num1 = fun(num2); (o) -> fun()은 정수값 반환
int& num1 = fun(num2); (o) -> fun()은 참조자 반환

#int fun(int &a)
int num1 = fun(num2); (o) -> fun은 정수값 반환
int& num1 = fun(num2); (x) -> 에러

#int& fun(int a)
int &num1 = fun(int a) (x) -> 컴파일에러는 안나지만 잘못된 것임
#############################################################################
#include<iostream>

int integer(int &a) {
	a++;
	return a;

}

int& Reference(int& a) {
	a++;
	return a;

}



int main() {
	int a = 10;
	//int &b = integer(a); -> 당연히 에러, b는 참조자로 변수 이름으로 초기화해야함
	std::cout << a << std::endl;
	
	int& b = Reference(a);
	std::cout << a << std::endl;

	int c = Reference(a); //c에는 a의 "값"이 들어감 (함수 반환형이 참조자여도)
	c = 100 + c;
	std::cout << a << std::endl;

}
#############################################################################
10
11
12




(5) 잘못된 참조자의 반환
int &fun(int a) 형태인 경우 문제가 생긴다. -> 이 문장 자체가 잘못된 문장이다.
정상적으로 출력은 되지만 이는 곧 소멸될, 찌꺼기 형태로 남아 있는 데이터를 참조해서 보여주는 것뿐! 주의하자!

매개 변수를 int a로 받는다는 것은 "값"을 받는다는 것이다. 즉 함수를 불러온 main 함수의 변수를 참조자로 정의하는 것이
아닌 "값!"을 불러온것이다.

이때 fun() 함수는 main 함수의 어떠한 변수를 참조하는 참조자가 없기에 main 함수의 변수를 return하지 못한다. (참조자형태로)
즉 이때 fun() 함수의 지역함수 내의 변수를 return하게 되는데, 지역함수 로직이 끝나자마자 소멸이 되고 찌꺼기 데이터가 남는다.

그렇기에 아래 예제 c 변수는 fun() 함수 a를 참조하게 되지만 이는 찌꺼기 데이터이며 다른 메모리가 할당되어 이 값을 덮어 씌운다면
당연히 그 값은 정상적으로 보이게 되지 않을 것이다. 
#############################################################################
#include<iostream>

int& ref(int a) {
	a++;
	return a;
}

int main() {
	int b = 10;
	int &c = ref(b);
	std::cout << c;
}
#############################################################################
11




(6) const 변수를 참조하는 참조자는 const로 선언해야 한다. < - > const char * str = "hihi"; 이것과 같은 원리
const로 선언된 변수 a를 const가 아닌 참조자가 받아서 값을 변경시킬 우려가 있기에 컴파일러 에러를 띄운다.
#############################################################################
#include<iostream>

int& ref(int a) {

}

int main() {
	const int a = 10;
	//int& b = a; 에러
	const int& b = a;
} 
#############################################################################



(7) 참조자의 상수 참조
const int &a = 10;+
#############################################################################
#include<iostream>

int add(const int &a, const int &b) {
    return a + b;
}

/*
int add( int& a,  int& b) {
    return a + b;
}
인 경우 main()의 add(1,2)에서 에러 발생
*/
int main() {
    //만약 const int &b를 사용하지 않으면 b는 변수만을 받을 수 있다.
    //즉 add() 함수를 사용하기 위해서 상수가 아닌 변수에 담고 옮겨야하는 귀찮은 것이 있다.
    //그렇기에 만약 내가 사용하려는 함수가 참조자를 받는 함수라면 변수를 생성하여 넣어줘야 하지만 (매개 변수: int &a)
    //변수 상관 없이 바로 리터널 상수를 넣고싶다면 const를 붙이면 된다.
    
    //우리는 a = 10의 10을 리터널 상수라고 하는데 리터널 상수 (10)은 
    // a에 10을 저장하기 위해 임시적으로 메모리에 저장되어 있다가 a에 10을 저장한 후 10은 메모리에 사라져버린다.
    //즉 메모리에는 10을 저장하고 있는 a만이 메모리에 남게 된다.
    
    //자! 이제 우리는 어떻게 접근해야 참조변수를 받는 참조자가 리터널 상수를 받을 수 있을까
    //우리에게는 여러 조건이 필요하다.
    //1. 참조자가 가르키는 리터널 상수가 다음행으로 넘어가더라도 계속해서 참조할 수 있도록 메모리에 상주해야 한다.
    //2. 리터널 상수가 아닌 변수로써 10을 인식해야 한다.
    //우리 C++은 약속했다. const 참조자를 사용하여 리터널 상수를 참조할 때 해당 상수를 가르키는 "임시변수"라는 만들기로!
    //즉 10은 임시 변수화 되어 메모리에 상주, 변수로써 인식하게 된것이다.

    int a = 10;
    int b = 10;
    add(a, b);

    add(1, 2);


    return 0;
}
#############################################################################




(8) 참조자 헷갈리는거
#############################################################################
#include<iostream>

int main() {
	const int num = 12;
	const int* ptr = &num;
	//int * const ptr = &num 에러
	//
	const int *&ref = ptr;

	std::cout << *ptr << std::endl;
	std::cout << *ptr << std::endl;
	std::cout << *ref << std::endl;


	/*
	포인터 변수를 선언해서 위 변수 가르키기
	포인터 변수를 참조하는 참조자 선언하기 
	선언된 포인터 변수와 참조자를 이용하여 데이터 출력

	*/

}
#############################################################################







6. 동적 메모리 할당
malloc vs new, free vs delete
C++에서 malloc과 free, new와 delete로 동적 메모리를 할당할 수 있다.
동적 메모리 할당은 힙 메모리이다.


(1) malloc, free()
C언어와 동일하다.
#############################################################################
#include<iostream>
#include<string.h>
#include<stdlib.h>

char* returnChar(int size) {
	char* str = (char*)malloc(size);
	return str;
}

int main() {

	const char* str = returnChar(20);
	str = "hello world";

	const char* str1 = "hello world";

	std::cout << sizeof(str);
	std::cout << sizeof(str1);


	std::cout << str;
	std::cout << str1;

	free((void*)str);
}
#############################################################################
88hello worldhello world





(2) new & delete
malloc과 free의 불편한 점은 아래와 같다.
1. 할당할 대상을 무조건 바이트 크기 단위로 전달해야 함.
2. 반환형이 void이기에 적절한 형변환을 거처야 함

1) new
C++에서는 아래와 같이 동적으로 메모리할당이 가능하다.

int 형 변수 할당: int * ptr1 = new int;
double 형 변수 할당: int * ptr1 = new double;
길이가 3인 int 형 배열의 할당: int * arr1 = new int[3];
길이가 2인 double 형 배열의 할당: int * arr1 = new double[2];


2) delete

int 형 변수 소멸: delete ptr1;
double 형 변수 소멸: delete ptr1;
int 형 배열 소멸: delete []arr1;
double 형 배열 소멸: delete []arr1;


#############################################################################
#include <iostream>

char * ReturnChar(int size) {
	char* ptr = new char[size];
	return ptr;
}

int main() {
	char* ptr = ReturnChar(20);
	strcpy(ptr, "helloworld");
	delete []ptr;
}
#############################################################################




(1) 객체의 생성에는 반드시 new & delete

malloc으로 생성 vs new로 생성 차이 비교
malloc: 클래스 만큼의 메모리만 할당이 된다. 클래스의 내용 상관 X
new: 생성자 클래스의 내용에 따라 객체가 생성된다.


#############################################################################
#include <iostream>

class Student {
public: Student() {
	std::cout << "student 생성자 실행";

}

	  int age;
};

int main() {

	Student* st1 = (Student*)malloc(sizeof(Student) * 1);
	//st1.age = 10; 에러

	Student * s2 = new Student;
	//stduent 생성자 실행
	s2->age = 20;
}
#############################################################################



(2) new 연산자를 이용하여 할당된 메모된 메모리 공간에 참조자 선언
참조자의 선언은 상수가 아닌 변수만 가능하다.(const 참조자가 아닌 경우)
C++에서는 new 연산자를 이용해서 할당된 메모리 공간도 변수로 간주한다.
즉 new 연산자를 이용하여 할당된 메모리 공간에 참조자 선언이 가능하다.
#############################################################################
#include <iostream>

int main() {

	int* ptr = new int;
	int& ref = *ptr;
	ref = 20;
	std::cout << *ptr;
}
#############################################################################






7. C++에서 C언어 표준 라이브러리 호출하기
C의 표준 라이브러리를 사용하고 싶으면 C를 더하고 h를 뺴라
#include <stdio.h> -> #include<cstdio>





