1. const 의미

***const(*ptr3 상수화 즉 &a가 가르키는 값 상수화) int * const(&a 주소를 상수화) ptr3 = &a;

#############################################################################
#include<iostream>

int main() {

    const int a = 10;
    // a = 20; // 에러: const 변수의 값을 수정할 수 없습니다.

    int b = 20;
    int c = 30;

    const int* ptr1 = &b;
    ptr1 = &b; // 가능: ptr1은 상수 정수를 가리키는 포인터이므로 다른 상수 정수를 가리키도록 할 수 있습니다.
    //*ptr1 = 3;

    int* const ptr2 = &b;
    //ptr2 = &c;
    *ptr2 = 30;



    const int* const ptr3 = &a;
    //ptr2 = &a; // 에러: const 포인터를 수정할 수 없습니다.
    //*ptr2 = 3; //에러

}
#############################################################################




2. 메모리 

데이터: 전역변수가 저장되는 영역
스택: 지역 변수, 매개변수가 저장되는 영역
힙: malloc 함수 호출에 의해 프로그램이 실행되는 과정에서 동적으로 할당이 이루어지는 영역

malloc & free: malloc으로 할당된 메모리는 free함수 호출을 통해 소멸하지 않으면 해제되지 않음



3. call by value, call by reference

#############################################################################
#include<iostream>

void CallByValue(int a, int b) {
	int c = b;
	a = b;
	b = c;
}

void CallbyRefer(int* a, int* b) {
	int temp = *b;
	*b = *a;
	*a = temp;


}

int main() {
	int a = 1, b = 2;
	CallByValue(a, b);
	std::cout << a << "  " << b << std::endl;
	
	CallbyRefer(&a, &b);
	std::cout << a << "  " << b << std::endl;

}
#############################################################################
1  2
2  1 



4. bool의 의미
bool은 1byte 데이터이다. 0, 1만을 표현함
0은 False, 1은 True를 표현함
0 자체가 False, 1이 True를 의미하는 것이 아니라 표현하는 것임
#############################################################################
#include<iostream>

int main() {

	std::cout << true << std::endl;
	std::cout << false << std::endl;
	std::cout << sizeof(true) << std::endl;
	std::cout << sizeof(false) << std::endl;
}
#############################################################################



5. 참조자의 이해

우선 변수는 메모리 공간에 붙여진 "이름(별칭)"임 
이 이름을 통해 같은 메모리를 바라보는 또 다른 별칭?를 선언할 수 있음
이때 참조자를 선언을 통해 이를 가능하게 할 수 있음

int &num = num1; 이런식으로 가능함

*** &의 두가지 의미
1. 선언된 변수의 & (int * ptr = &num): 해당 변수의 주소값 반환
2. 선언되는 변수의 &(int &num = num1): 변수 num1에 대한 참조자 num을 선언해라

그럼 변수와 참조자는 같은 걸까?
변수로 봐도 무리는 없지만 C++에서는 분리해서 보고있음
즉 변수를 참조하여 생성된 참조자는 참조라라는 별도의 이름을 가진다.


#############################################################################
#include<iostream>

int main() {

	int num1 = 10;
	int &num = num1;
	std::cout << num1 << "     " << num << std::endl;

}
#############################################################################
10     10




(1) 참조자는 별칭이다.
C++에서는 참조자를 변수에 별칭을 지어주는 것이라고 봄
그렇다!!! 참조자는 변수의 또 다른 이름을 지어준다고 보자!
무조건!!! 선언과 동시에 변수를 참조하도록 해야한다.




(2) 참조자를 응용
참조자를 사용할 때는 함수가 큰 위치를 차지함 (매개변수를 넘길떄)
그렇기에 참조자를 이용한 call-by-refernce 예제를 설명하려 한다.
-> 예제에서 int &a는 선언과 동시에 변수를 참조해야하는데 예제는 아니네요 왜그렇죠?
매개변수의 기본 역할 자체는 함수의 호출과 동시에 인자로 초기한다. 그렇기에 이는 문제가 없다.
(디폴트 함수 제외)
#############################################################################
#include<iostream>

void callByRefer(int &a, int &b) {
	int temp = a;
	a = b;
	b = temp;
}

int main() {
	int a = 10, b = 20;
	callByRefer(a, b);
	std::cout << a << "     " << b << std::endl;


}
#############################################################################


(3) 참조자를 이용한 call by refernce의 문제점과 해결방안
결론적으로 C++ 개발자는 함수를 만들 때 참조자를 매개변수로 이용하지 않으려한다.
왜냐하면 예를 들어 아래와 같은 로직이 있다고 가정해보겠다.

int num = 24;
HappyFunc(num);

여기서 HappyFunc 함수에 들어가서 num의 값이 변경하지 않을 것이라는 보장이 있는가?
C에서는 참조자가 없기에 24가 출력되지만, C++에서는 보장할 수 없다.
즉 HappyFunc 함수까지 들어가서 인자를 int &a 이런식으로 받는지 확인해야 하는 것이다.

해당 문제를 해결하기 위해서는 함수를 선언할 때 const를 붙이면 된다.
void HappyFunc(const int &a); -> 이런식으로
그렇다면 HappyFunc 함수 내에서 a의 값을 변경하려고 할 때 에러를 띄울 것이다.



(4) 반환형이 참조자일 경우
기본형 -> int &fun(int &a)

예제) 
#int &fun(int &a)
int num1 = fun(num2); (o) -> fun()은 정수값 반환
int& num1 = fun(num2); (o) -> fun()은 참조자 반환

#int fun(int &a)
int num1 = fun(num2); (o) -> fun은 정수값 반환
int& num1 = fun(num2); (x) -> 에러

#int& fun(int a)
int &num1 = fun(int a) (x) -> 컴파일에러는 안나지만 잘못된 것임
#############################################################################
#include<iostream>

int integer(int &a) {
	a++;
	return a;

}

int& Reference(int& a) {
	a++;
	return a;

}



int main() {
	int a = 10;
	//int &b = integer(a); -> 당연히 에러, b는 참조자로 변수 이름으로 초기화해야함
	std::cout << a << std::endl;
	
	int& b = Reference(a);
	std::cout << a << std::endl;

	int c = Reference(a); //c에는 a의 "값"이 들어감 (함수 반환형이 참조자여도)
	c = 100 + c;
	std::cout << a << std::endl;

}
#############################################################################
10
11
12




(5) 잘못된 참조자의 반환
int &fun(int a) 형태인 경우 문제가 생긴다. -> 이 문장 자체가 잘못된 문장이다.
정상적으로 출력은 되지만 이는 곧 소멸될, 찌꺼기 형태로 남아 있는 데이터를 참조해서 보여주는 것뿐! 주의하자!

매개 변수를 int a로 받는다는 것은 "값"을 받는다는 것이다. 즉 함수를 불러온 main 함수의 변수를 참조자로 정의하는 것이
아닌 "값!"을 불러온것이다.

이때 fun() 함수는 main 함수의 어떠한 변수를 참조하는 참조자가 없기에 main 함수의 변수를 return하지 못한다. (참조자형태로)
즉 이때 fun() 함수의 지역함수 내의 변수를 return하게 되는데, 지역함수 로직이 끝나자마자 소멸이 되고 찌꺼기 데이터가 남는다.

그렇기에 아래 예제 c 변수는 fun() 함수 a를 참조하게 되지만 이는 찌꺼기 데이터이며 다른 메모리가 할당되어 이 값을 덮어 씌운다면
당연히 그 값은 정상적으로 보이게 되지 않을 것이다. 
#############################################################################
#include<iostream>

int& ref(int a) {
	a++;
	return a;
}

int main() {
	int b = 10;
	int &c = ref(b);
	std::cout << c;
}
#############################################################################
11
