[문자열]

********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
C 언어에서 문자열의 끝을 나타내기 위해 널 종료 문자(\0)를 사용합니다. 널 종료 문자는 ASCII 코드로 0에 해당하는 문자로, C 언어에서 문자열의 끝을 나타내는데 사용됩니다.

예를 들어, "Hello"라는 문자열은 다음과 같이 표현됩니다:

arduino
Copy code
'H' 'e' 'l' 'l' 'o' '\0'
C 언어에서 문자열 함수들은 널 종료 문자를 기준으로 문자열의 끝을 감지하며, 따라서 문자열 처리가 가능합니다. 예를 들어, strlen() 함수는 문자열의 길이를 계산할 때, 
널 종료 문자를 만날 때까지 문자를 세어나갑니다.

문자열을 직접 선언할 때에는 컴파일러가 자동으로 널 종료 문자를 추가해주기 때문에 사용자가 따로 넣을 필요는 없습니다. 하지만 문자열을 다룰 때 주의해야 할 점은 
널 종료 문자가 포함된 공간을 반드시 확보해야 한다는 점입니다. 즉, 문자열의 크기를 선언할 때 널 종료 문자까지 고려하여 충분한 크기를 할당해야 합니다.

예를 들어, "Hello" 문자열을 저장하기 위해 최소 6개의 문자를 저장할 수 있는 배열이 필요합니다:

c
Copy code
char str[6] = "Hello"; // 배열 크기는 "Hello" + 널 종료 문자('\0')를 포함하여 6
만약 배열 크기가 충분하지 않다면, 문자열이 잘릴 수 있거나 메모리 침범 오류가 발생할 수 있습니다. 따라서 문자열을 다룰 때는 항상 널 종료 문자를 고려하여 크기를 결정하는 것이 중요합니다.

-> 즉 문자열은 자신의 주소를 가르키는데 끝의 주소를 가르키지 않아도 null 값을 보고 알아낼수있다.
********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************



1. 문자열 선언과 입출력



(1) 문자열 선언

char 배열명[크기] = "문자열";
char 배열명[] = "문자열";
##############################################################################################################################################
#include <stdio.h>

int main() {
	
	char str[] = "hihiihi";
	char str2[8] = "hihiihi";
	
	//char str4[7] = "hihiihi"; -> 에러, 담는 것보다 선언하는 것이 커야함. null 포함 8byte를 할당해야 하기 때문

	char str3[9] = "hihiihi";

	printf("%s", str3);

}
###############################################################################################################################################










(2) 문자열 입출력



1) 문자 입출력함수 putchar, getchar()
한글자를 받고, 한글자를 출력하는 함수
###############################################################################################################################################
#include <stdio.h>

int main() {
	
	char a = getchar();

	putchar(a);

	//a
	//a

}
###############################################################################################################################################








2) 문자열 입출력 함수 fgets(), fputs()
***scanf_f, printf_s와 같은 역할을 수행한다고 보면 된다.
###############################################################################################################################################
#include <stdio.h>
#include <stdlib.h>

int main() {
    char str[10];

    printf("문자열을 입력하세요: ");
    fgets(str, sizeof(str), stdin);
    //stdin은 표준 입력 스트림

    printf("입력된 문자열: ");
    fputs(str, stdout);
    //stdout는 표준 출력 스트림임

    return 0;
}
###############################################################################################################################################






(3) 문자열 수 변환  sscanf_s, sprintf_s
sscanf_s는 입력으로 사용할 문자열, str에서 읽어들인 데이터의 형식을 지정하는 서식 문자열("%d.."), 포맷 스트링으로 따라 파싱된 데이터를 저장할 변수
sprintf_s 함수는 문자열로 저장될 버퍼의 포인터, 버퍼오버플로 방지, 출력되고, 버퍼의 포인터 즉 문자열로 저장될 포맷 스트링, 포맷스트링으로 표시될 데이터
###############################################################################################################################################
#include <stdio.h>
#include <stdlib.h>

int main() {
    int num;
    char str[100];

    printf("정수를 입력하세요: ");
    fgets(str, sizeof(str), stdin);
    //stdin은 표준 입력 스트림
    sscanf_s(str, "%d", &num);
    //값을 str로 받고, 해당 문자열을 정수형으로 바꾼 뒤 &num에 저장함.
    printf("입력된 정수: %d\n", num);
    printf("입력된 문자열: %s\n", str);

  
    char numStr[20];
    sprintf_s(numStr, sizeof(numStr), "%d", num);
    //정수 num값도 출력도 하고, 문자열로 변환하여 numStr 버퍼에 저장하는 로직

    printf("정수를 문자열로 변환한 결과: %s\n", numStr);

    return 0;
}

###############################################################################################################################################







(4) 문자열을 수로 변환하는 함수
int atoi(char *str); -> 문자열 str을 int 변형
long atol(char *str); -> "을 long 변형
double atof(char *str); "를 double 부동소수점형으로 변환
###############################################################################################################################################
#include <stdio.h>
#include <stdlib.h>

int main() {
   
    char str[] = "25999";
    int a = 3000 + atoi(str);
    printf("%d", a);
    //28999

    return 0;
}
###############################################################################################################################################







































2. 포인터와 문자열

char de[3] = "hi";와 const char *de = "hi";의 주요 차이점은 메모리 구조 및 할당 방식에 관련이 있습니다. 아래에서 이 두 방식의 메모리 처리 방식을 자세히 설명하겠습니다:

char de[3] = "hi";:

de는 문자 배열로 선언됩니다. 크기가 3인 문자 배열 de를 선언하고 초기화하여 "hi" 문자열을 저장합니다.
이 배열은 스택 메모리에 할당됩니다. 스택 메모리는 프로그램 실행 중에 잠깐 사용되며, 지역 변수와 함수 호출 스택 프레임에 사용됩니다.
"hi" 문자열의 각 문자('h'와 'i')가 배열 de의 각 요소에 복사됩니다.
이 배열은 수정 가능하며, de를 통해 배열의 각 요소를 변경할 수 있습니다.

Copy code
+---+---+---+
| h | i | \0|  // de 배열 메모리
+---+---+---+
const char *de = "hi";:

de는 문자열 포인터로 선언됩니다. 이 포인터는 "hi" 문자열 상수의 메모리 주소를 가리킵니다.
"hi" 문자열 상수는 프로그램의 코드 세그먼트 또는 데이터 세그먼트에 저장됩니다. 이 메모리 영역은 읽기 전용이며, 문자열 상수를 수정할 수 없습니다.
de는 문자열 상수의 주소를 저장하므로 de를 통해 문자열을 변경할 수 없습니다.

Copy code
+---+        +---+---+---+
| de| -----> | h | i | \0|  // "hi" 문자열 상수와 de 포인터 메모리
+---+        +---+---+---+
요약하면, char de[3] = "hi";는 스택에 배열을 생성하고 초기화하여 문자열을 직접 저장하므로 수정 가능합니다. 반면에 const char *de = "hi";는 포인터가 문자열 상수의 메모리 주소를 가리키므로 문자열 자체를 수정할 수 없으며, 문자열 상수는 읽기 전용입니다.
또한 배열의 사용하여 특정 인덱스에 있는 문자열을 가져오지 못함
const char *de ="hi";
printf("%s", de[0]); //-> 읽어들이지 못함

###############################################################################################################################################
#include <stdio.h>
#include <stdlib.h>
#include <string>

int main() {

	char a[] = "Hi";
	a[0] = 'i';


	printf("%s\n", a);
	/*
	아래 에러
	a[] = "hihi";
	a = "hihi";
	*/

	int inte[] = { 1,3,4 };

	/*
	아래 에러
	const int* inte2 = { 2,3,4 };
	inte[] = {2,3,3};
	inte = { 1,3,4 };
	
	*/

	//char* b = "bye"; -> 오류
	const char* b = "bye"; //-> 오류 x

	printf("%s", b);
	//bye

}
###############################################################################################################################################





포인터를 이용한 문자열 입출력
###############################################################################################################################################
#include <stdio.h>
#include <stdlib.h>
#include <string>

int main() {
	;
	char name[10];
	scanf_s("%s", name, sizeof(name));

	printf("%s", name);
	//hkj
	//hkj

	printf("%c", *(name + 1));
	//abc
	//abcb

	
}
###############################################################################################################################################









































3. 여러 문자열 함수들
###############################################################################################################################################

#include <stdio.h>
#include <stdlib.h>
#include <string>

int main() {

	char str1[] = "hello world";
	char str2[] = "bye world";

	int a = strlen(str1);
	//문자열 str의 길이 반환


	strcpy(str1, str2);
	//문자열 str2를 문자열 str1으로 복사한다.
	printf("%s\n", str1);
	//bye world


	char str3[100] = "abcde";
	strcat(str3, str1);
	//문자열 str3에 str1 내용을 넣기
	printf("%s\n", str3);
	//abcdebye world


	printf("%d\n", strcmp(str1, str3));
	//1
	//두 문자열이 같으면 0 반환, str1이 더 크면 양수, 작으면 음수 반환

	printf("%s\n", strchr(str1, 'w'));
	//world
	//str1에 w 문자가 처음 보이는 곳을 반환한다.

	const char* b = "bye";


	printf("%s", strstr(str1, "wor"));
	//world
	//str1에 wor 문자가 처음 보이는 곳을 반환한다.


	char str[] = "apple,banana,grape,orange";
	const char delim[] = ",";

	// 첫 번째 토큰을 얻기 위해 strtok에 문자열 포인터를 전달합니다.
	char* token = strtok(str, delim);

	// strtok이 반환하는 포인터가 NULL이 아닐 때까지 반복하여 토큰을 출력합니다.
	while (token != NULL) {
		printf("Token: %s\n", token);

		// 다음 토큰을 얻기 위해 strtok에 NULL을 전달합니다.
		token = strtok(NULL, delim);
	}

	return 0;
}

	/*
	token = strtok(NULL, delim);은 strtok 함수를 호출하여 다음 토큰을 얻는 부분입니다.
	strtok 함수는 첫 번째 인자로 넘겨준 문자열 포인터를 기준으로 두 번째 인자로 넘겨준 구분자를 찾아 해당 구분자를 널 문자(\0)로 바꿉니다.그렇게 하면 원본 문자열은 수정되며, strtok 함수는 첫 번째 토큰의 시작 주소를 반환합니다.첫 번째 호출 시에는 넘겨준 문자열 포인터가 처음을 가리키도록 해야 합니다.

	첫 번째 토큰을 얻은 후에는 이후에 호출된 strtok(NULL, delim);을 통해 다음 토큰을 얻을 수 있습니다.이때, 첫 번째 인자로 NULL을 넘겨주어야 합니다.strtok 함수는 이전에 자른 문자열을 기억하고 있으며, 이전의 구분자 이후부터 새로운 구분자까지를 다음 토큰으로 반환합니다.그리고 더 이상 자를 토큰이 없을 경우, NULL을 반환하여 표시합니다.

	위에서 보여준 코드에서 두 번째 strtok(NULL, delim); 호출은 이전에 얻은 첫 번째 토큰 이후부터 새로운 구분자까지를 다음 토큰으로 얻기 위해 호출되는 것입니다.이런 방식으로 while 루프를 통해 모든 토큰들을 순차적으로 얻을 수 있습니다.
	*/
###############################################################################################################################################














4. 문자열과 포인터 배열
##############################################################################################################################################################################################################################################################################################
#include <stdio.h>
#include <stdlib.h>
#include <string>

int main() {

	char str[3][100] = { "hi", "bye", "JaiZian"};
	const char* ptr[3] = { "hi", "bye", "JaiZian" };
	//char* ptr[3] = { "hi", "bye", "JaiZian" }; -> 에러
	int a[] = {1,2,3};
	int b = 1;
	int c = 2;
	int d = 3;
	int* ptr2[3] = { &b, &c, &d };
	//int* ptr2[3] = { 1,2,3 }; -> 에러



	for (int i = 0; i < 3; i++) {
		printf("%s \n", &str[i][0]);
	}
	//문자열은 자신의 첫번째 원소의 주소를 가르킨다



	for (int i = 0; i < 3; i++) {
		printf("%s \n", str[i]);
	}
	//위와 마찬가지 
	

	for (int i = 0; i < 3; i++) {
		printf("%s \n", ptr[i]);
	}
	//hi bye JaiZian


	//아래는 주소 값출력
	for (int i = 0; i < 3; i++) {
		printf("%d \n", ptr2[i]);
	}


	//아래는 값 출력
	for (int i = 0; i < 3; i++) {
		printf("%d \n", *ptr2[i]);
	}	
	//1
	//2
	//3


}
##############################################################################################################################################################################################################################################################################################












5.  main() 인자
main의 매개 변수를 각각 argc, argv라고 하며 argc는 명령줄 인수의 개수를 저장하기 위한 정수형 변수이고, argv[]는 명령줄 인수들을 저장하기 위한 문자열 포인터 배열임.

##############################################################################################################################################################################################################################################################################################
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("Program name: %s\n", argv[0]);

    if (argc > 1) {
        printf("Arguments:\n");
        for (int i = 1; i < argc; i++) {
            printf("Argument %d: %s\n", i, argv[i]);
        }
    } else {
        printf("No arguments.\n");
    }

    return 0;
}
##############################################################################################################################################################################################################################################################################################

위의 코드는 프로그램의 이름과 명령행 인자들을 출력하는 간단한 예제입니다. 예를 들어, 실행 파일을 example.exe로 컴파일하고 아래와 같이 실행하면:

Copy code
example.exe arg1 arg2 arg3
다음과 같은 결과를 얻을 수 있습니다:

Program name: example.exe
Arguments:
Argument 1: arg1
Argument 2: arg2
Argument 3: arg3
만약 실행 파일을 단독으로 실행한다면(example.exe), argc는 1이 되고 인자들을 받지 않은 것으로 처리됩니다. 이럴 경우 "No arguments." 메시지가 출력됩니다.
