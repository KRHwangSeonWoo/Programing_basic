[변수와 자료형]

1. 상수 
const 지시자를 사용하여 상수임을 알린다. 한번 초기화하면 수정이 불가하다.

[문자열 "상수"의 독특한 const!]
const char* msg = "hi";
//가능 
char* msg2 = "hi";
//불가능
[const char*] b = "bye"같이 선언하는 것은 일반적으로 문자열만 가능한데,
문자열 상수는 일반적으로 읽기 전용 메모리에 저장되기 때문임. 따라서 char* 타입의 포인터를 사용하여 문자열 상수를 가리키는 것은 
문자열 내용을 수정할 수 있는 위험을 갖고 있습니다. 하지만 C 언어에서는 묵시적으로 문자열 상수를 const char* 타입으로 취급하여 이러한 위험을 방지합니다.
즉, "hi"는 문자열 상수이므로 수정할 수 없습니다. (배열 요소를 변경하는 것은 가능함.)
그리고 const char* 타입으로 선언된 포인터는 문자열 내용을 수정할 수 없는 것을 보장합니다.
############################################################################################################################
#include <stdio.h>

int main() {

	const int a = 1;
	
	//에러 발생 -> 상수이기에 수정 불가
	//a = 2;

	//const int a;로 할시 에러 발생 -> 상수이기에 초기화해줘야 함

	printf("%d", a);
	//결과 : a


}
############################################################################################################################


2. 정수형
정수형에는 5가지가 있다.
char, short, int, long, long long이 있다. 이 정수형의 차이점은 메모리로부터 할당받는 크기가 다르다. 즉 숫자의 크기가 다르다.
넓은 의미에서 char는 정수형임을 유의하자.


1) 정수형 자료형의 크기
############################################################################################################################
#include <stdio.h>

int main() {

	printf("char 크기 %d\n", sizeof(char));
	printf("short 크기 %d\n", sizeof(short));
	printf("int 크기 %d\n", sizeof(int));
	printf("long 크기 %d\n", sizeof(long));
	printf("long long 크기 %d\n", sizeof(long long));

	/*	
char 크기 1
short 크기 2
int 크기 4
long 크기 4
long long 크기 8
	*/

}
############################################################################################################################


정수 리터널은 모두 int라고 가정하고, L이나 l이 정수 끝에 붙으면 long 리터널, LL 혹은 ll이 붙으면 long long 리터널이다.
리터널을 사용하지 않아도 상관은 없지만, 해당 접미사의 표시된 자료형으로 표현하도록 컴파일러에게 알려주는 역할을 합니다. 이를 통해 해당 값이 원하는 범위 내에서 처리되도록 보장할 수 있습니다.
############################################################################################################################
#include <stdio.h>

int main() {
 
	short a = 10;
	int b = 20;
	
	int c = 2222222;
	long long d = 2222222222222222222LL;
	
	printf("%d\n", c);
	printf("%lld\n", d);

	/*
2222222
2222222222222222222
	*/

	long long f = 2222222222222222222;
	printf("%lld\n", f);
	//리터널 안 붙여도 문제없음
	//2222222222222222222
}
############################################################################################################################







3. 부동소수점 자료형
############################################################################################################################
float, double, long double이 있고 마찬가지로 담을 수 있는 값의 용량이 다르다.

#include <stdio.h>

int main() {
 
	float a = 0.123;
	double b = 0.123456789012345;
	long double c = 0.1234567890123456;
		
	printf("%.15Lf\n%Lf\n%.15Lf", a, b, c);
	//.15 등을 이용하여 출력할 수소점 밑 개수를 지정할 수도 있다.

}
############################################################################################################################








4. 문자형
char는 1바이트를 할당하게 되는데, 이는 문자 한개이다. 문자 여러개를 사용하고 싶은경우 배열을 사용해야 한다.
############################################################################################################################
#include <stdio.h>

int main() {
 
	char a = 'a';
	printf("%c", a);
	//a 출력됨.
}
############################################################################################################################














5. unsigned 자료형
unsigned는 부호를 (-)를 제외한 양의 정수만을 담는다. 즉 더욱 많은 값을 저장할 수 있다. (2배)

unsiged char -> 255
unsigned short -> 65545
unsigned int -> 4294967295
unsinged long (long long ) -> 19446744073709551715

"unsigned를 사용하지 않고 int 형으로 4294967295 값을 담을 수 있는 이유는 int 자료형의 범위가 충분히 크기 때문입니다.

int 자료형은 보통 32비트로 구성되며, 부호 있는 정수 값을 표현하는 데 사용됩니다. 일반적으로 int 자료형은 -2,147,483,648부터 2,147,483,647까지의 값을 표현할 수 있습니다. 이 범위는 32비트를 사용하는 대부분의 컴퓨터 시스템에서 지원됩니다.

하지만 4294967295는 부호 없는 값이므로 unsigned int로 표현하는 것이 더 적절합니다. unsigned int 자료형은 0부터 4,294,967,295까지의 값을 표현할 수 있습니다. 이 범위는 4294967295를 포함하고 있기 때문에 unsigned int로 변수를 선언하는 것이 더 정확한 표현입니다.

그러나 int 자료형으로 4294967295 값을 담는 것은 일반적으로 문제가 되지 않습니다. int 자료형의 범위를 넘어서는 경우 값의 오버플로우가 발생하며, 오버플로우된 값은 맨 앞 비트로부터 해석됩니다. 

즉, int 자료형으로 4294967295 값을 담으면 -1로 해석되지만, 값 자체는 여전히 4294967295입니다. 따라서 값을 직접 비교하거나 연산하는 경우에는 주의해야 합니다. 만약 부호 없는 값에 관심이 있는 경우, unsigned int 자료형을 사용하여 명시적으로 표현하는 것이 좋습니다."

#############################################################################################################################
#include <stdio.h>
int main() {

	  int a = 9223372036854775807;

	  long long b = 9223372036854775807;

	  printf("%d", a);
	  //-1
	  printf("%d\n", b);
	  //-1

	  printf("%lld\n", a);
	  //4294967295 -> 정상적으로 출력되긴 함
	  printf("%lld\n", b);
	  //9223372036854775807

}
#############################################################################################################################






6.  변수와 유효 범위



1) 지역 변수 
{ } 안에 선언된 변수는 지역변수로 { }안에서만 사용이 가능하다. 
또한 아래처럼 함수 내에 { { } }처럼 구분할 수 있는데 마찬가지로 { }안에 선언되어야만 해당 지역에서 사용이 가능하다.

##################################################################################################################################
#include <stdio.h>

int num() {

	//printf("%d", a); -> 오류 발생
	
	{
		int a = 10;
		return a;
	}
}

int main() {
	num();
}
##################################################################################################################################


정적 지역변수
정적 지역 변수는 지역 변수이기에 프로그램 함수 내에서만 사용이 가능하고, 다른점은 프로그램 실행 후에서 종료까지 메모리에 저장되어 있다.

한편 정적변수는 함수의 매개변수로 사용할 수 없다는 특성이 있다.
매개변수에 static을 붙이더라도 매개변수는 정적 변수가 되지 않으며 값이 유지되지 않는다.
##################################################################################################################################
void increaseNumber(static int num1){    // 정적 변수는 매개변수로 사용할 수 없음. 잘못된 문법
                                       // warning C4042: 'num1': 저장소 클래스가 잘못되었습니다.
    printf("%d\n", num1);
    num1++;
}
##################################################################################################################################


##################################################################################################################################
#include <stdio.h>

int static_var() {
	static int a = 0;
	return a++;
}
int main() {

	printf("%d", static_var());
	//0
	printf("%d", static_var());
	//1

}
##################################################################################################################################









2) 전역 변수
{ }안에 생성되지 않고 밖에 생성된 경우 비지역변수, 전역변수라고 부른다.
또한 선언된 파일 내의 있는 함수들만 사용이 가능하기에 파일범위변수라고도 부른다. (#include한 것의 전역변수도 당연히 사용할수 있겠죠?, extern 등등..)
또한 전역 변수에 static 키워드를 붙이면 파일 안에 있는 함수만 볼 수 있는데 이를 파일 범위 변수라고 부른다. 이것은 함수도 마찬가지이다.
한편 정적변수는 함수의 매개변수로 사용할 수 없다는 특성이 있다.
매개변수에 static을 붙이더라도 매개변수는 정적 변수가 되지 않으며 값이 유지되지 않는다.

##################################################################################################################################
void increaseNumber(static int num1){    // 정적 변수는 매개변수로 사용할 수 없음. 잘못된 문법
                                       // warning C4042: 'num1': 저장소 클래스가 잘못되었습니다.
    printf("%d\n", num1);
    num1++;
}
##################################################################################################################################


##################################################################################################################################
#include <stdio.h>

int b = 10;

int main() {
	
	printf("%d", b);
	//10
}
##################################################################################################################################


전역 static 변수
##################################################################################################################################
#include <stdio.h>

int num2 = 20;

static int sta = 1;

void get_10() {
	printf("10");
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>

extern int num2;

extern void get_10();
//10

//extern static int sta;
//오류 발생 -> 전역 변수 + static은 선언된 파일에서만 사용이 가능함.
int main() {

	printf("%d", num2);

	get_10();
	//20
	

}
##################################################################################################################################


##################################################################################################################################
#include <stdio.h>

// hi() 함수의 선언을 추가합니다.


int main() {
    extern int hi();
    hi();
    return 0;
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>

int num2 = 20;

// hi() 함수의 정의를 추가합니다.
//static int hi() { -> 에러 발생
 int hi() { 

    printf("hi");
    return 1;
}
##################################################################################################################################










7. 형변환

1) 자동형 변환
정수형과 부동소수점형이 섞여있을 경우 정수형을 부동소수점형으로 바꾸어 계산한다.
이것을 자동형변환이라고 한다.
############################################################################################################################
#include <stdio.h>

int main() {
    int a = 10;
    int b = 7;
    printf("%d\n" , (a / b));

    float c = 10;
    printf("%f", (c / b));
}
############################################################################################################################







2) 명시적 형변환
탑입 캐스팅 연산자를 이용한 형변환 -> (자료형)을 통해서 명시적으로 자료형을 정립한다.
또한 캐스트 연산자가 숫자 연산자보다 우선순위가 높다.
############################################################################################################################
#include <stdio.h>

int main() {
    int a = 10;
    int b = 7;
    printf("%f\n" , (float) a / b);
    //1.428571

    printf("%f\n", (float) (a / b));
    //1.000000
}
############################################################################################################################








8. 열거형
정수 상수 집합을 하나의 자료형으로 정리하는 방법임
아무런 값을 정의하지 않으면 순서대로 값이 들어감 (0,1,2,3..)
############################################################################################################################
#include <stdio.h>

enum number {
	one, two, tree, four = 9999
};

int main() {
 
	enum number n;

	n = one;
	printf("%d\n", n);
	//0

	n = two;
	printf("%d\n", n);
	//1
	n = four;
	printf("%d\n", n);
	//9999

}
############################################################################################################################














9. 형 정의
typedef는 자료형에 새로운 이름을 만들기 위해 사용되는 예약어임.
typedef는 struct로 선언된 구조체에 새로운 이름을 부여하는데 많이 사용됨.
############################################################################################################################
#include <stdio.h>

int main() {
 
	typedef int num;
	num a = 1;
	printf("%d", a);
	//1

}
############################################################################################################################

