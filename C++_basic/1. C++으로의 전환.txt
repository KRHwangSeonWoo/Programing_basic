[1. C++으로의 전환]


1. printf와 scanf를 대신하는 입출력

데이터의 입출력 시 데이터 포맷 지정이 필요 없음 (포맷 스트링이 필요없음)


(1) 문자열 Hello world의 출력

############################################################
#include<iostream>
int main(void) {
	std::cout << "Hello World" << std::endl;
	std::cout << "Hell " << "World!" << std::endl;
	std::cout << "Hell " << "World!";
	std::cout << "Hell " << "World!";
}
실행 결과:
Hello World
Hell World!
Hell World!Hell World!
############################################################

#관찰 포인트

1) 헤더 파일 선언문 #include<iosstream>
std, cout, endl와 같은 것을 선언하기 위해서는 위의 헤더 파일 선언문이 추가되어야 함.
또한 표준 헤더 파일에서는 확장자를 생략하기로 약속했다!!!

2) std::cout와 << 연산자를 이용한 출력
C에서는 %d, %s로 출력 포맷을 지정했다. 하지만 위 출력 방식은 C언어보다 편리함
std::cou, <<, std::endl이 제대로 어떤 의미 인지 알기위해서는 진도를 나가야 한다고 한다.

3) <<의 연이은 출력과 개행
std::cout <<"출력대상" <<"출력대상" <<std::endl와 같이 연이은 출력과 개행이 가능함
\n로도 개행이 가능하긴 하다. 하지만 가독성이 떨어져보임





(2) scanf를 대신하는 데이터의 입력

############################################################

#include<iostream>

int main(void) {
	int num1;
	std::cout << "숫자 입력";
	std::cin >> num1;
	std::cout << num1 << std::endl;


	char str[30];
	std::cout << "문자열 입력";
	std::cin >> str;
	std::cout << str << std::endl;


	int num2;
	std::cout << "숫자 입력";
	std::cin >> num2;
	std::cout << num2 << std::endl;
}
실행 결과:
숫자 입력1
1
문자열 입력hello
hello
숫자 입력1.3
1
############################################################

#관찰 포인트

1) 데이터 입력에 사용되는 std::cin과 >> 연산자
C++에서 데이터의 입력도 데이터의 출력과 마찬가지로 별도의 포맷 지정이 필요없다.
그렇기에 int 형으로 선언한 자료형을 int로 사용하고 싶으면 int로 선언하고 double로 사용하고 싶으면 double로 받으면 된다.

2) 문자열 입력도 마찬가지로 std::cin >> str로 사용하면 된다.

3) std::cin >> nul에서 int형에 1.3을 입력했을 때  생기는 현상
아래 결과와 같이 1.3\n을 입력했을 때 .3이 str이 입력되고 출력됨을 확인할 수 있다.
입력 버퍼에서는 키보드로 입력한 정보가 입력 버퍼에 저장되는데 이때 1.3\n을 입력 시 입력 버퍼의 있는 데이터 중에서 int형에서 저장할 데이터인 1만 읽고 나머지는 내버려둔다. 
즉 .3\n이 입력 버퍼에 남게되고 std::cin >> str; 코드에서 .3\n을 읽게되어 바로 .3이 출력되는 것이다.

***
그럼 1.3에서 .3을 읽을 때 오류가 나서 1만 읽고 1만 버퍼에서 삭제하고 나머지 .3은 남아있는거야?

ChatGPT
네, 맞습니다. std::cin에서 정수형 변수에 실수 값을 입력하면 오류가 발생하며, 입력 버퍼에는 오류가 발생한 시점까지의 데이터만 남게 됩니다. 예를 들어, 사용자가 "1.3"을 입력한 경우:

std::cin >> num1;에서는 실수값 "1.3"을 정수형 변수 num1에 입력하려고 시도합니다.
그러나 정수에 실수를 입력하면 변환이 불가능하므로 std::cin.fail()이 true가 됩니다.
입력 버퍼에는 "1.3"에서 "1"까지만 남게 됩니다. 소수점 이후의 ".3"은 입력 버퍼에 남아 있습니다.
이후에 다른 입력을 받을 때, 이전 입력에서 남아있는 ".3"이 올바른 입력으로 처리되지 않을 수 있습니다. 따라서 추가적인 처리 없이 다음 입력을 받을 경우에 문제가 발생할 수 있습니다. 이때는 std::cin.ignore()를 사용하여 입력 버퍼를 명시적으로 비워주는 것이 좋습니다.

############################################################
#include<iostream>

int main(void) {
	int num1;
	std::cout << "숫자 입력";
	std::cin >> num1;

	std::cout << num1 << std::endl;


	char str[30];
	std::cout << "문자열 입력";
	std::cin >> str;

	std::cout << str << std::endl;
}
숫자 입력1.3
1
문자열 입력.3

############################################################    


