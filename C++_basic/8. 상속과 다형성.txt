[상속과 다형성]


1. 객체 포인터 변수
객체를 생성하는 방법은 총 2개이다.
1) Student s1
2) Student *s2 = new Student();

*2)번에 객체 포인터 변수에서 객체의 참조 자료형을 클래스 생성자가 상속하는 다른 부모 클래스로 변경할 수 있다.
-> Person *p = new Student();
이경우 Person 클래스에 정의된 멤버만 사용 가능하다. (자식 클래스 멤버 호출 불가)
즉, 포인터 형에 해당하는 클래스에 정의된 멤버에만 접근이 가능

=>

Penson *p = new Student()
-> Person 형의 포인터 변수 선언 = Student 객체 생성
즉, Student 객체를 Person 형 포인터 변수로 담아서 사용함

Student 형으로 객체를 만들었는데, Person 담는 포인터 변수에서 Student 멤버에 접근이 왜 불가능한가요?
-> C++에서는 객체의 형을 실제 가르키는 객체의 자료형이 아닌 포인터의 자료형으로 판단한다.
그렇기에 C++ 컴파일러에서는 포인터 자료형 이외의 멤버를 호출할 경우 에러를 발생시키는 것이다. 
(어? 너 클래스에 정의안된 멤버인데? 삡~ 에러)
##########################################################################################
#include<iostream>

class animal {
public:
	void breath() {
		std::cout << "숨을 쉽니다.";
	}
};

class Person : public animal{
public:
	void talk() {
		std::cout << "말을 합니다.";
	}
};


class Student : public Person{

public: 

	int age;
	Student() {
		age = 20;
	}
public:
	void study() {
		std::cout << "공부를 합니다.";
	}
};


int main() {
	
	Student* s1 = new Student();
	s1->breath();

	Person* p1 = new Student();
	p1->breath();
	//p1->study(); -> 에러


	animal* a1 = new Student();
	a1->breath();
	//a1->talk(); -> 에러
	//p1->study(); -> 에러
	
	std::cout << sizeof(*s1);
	std::cout << sizeof(*a1);
	
}

숨을 쉽니다.
숨을 쉽니다.
숨을 쉽니다.
4
1
##########################################################################################














2. 함수 오버라이딩 VS. 함수 오버로딩
기초 클래스와 동일한 이름의 함수를 유도 클래스에서 정의한다고 해서 무조건 함수 오
버라이딩이 되는 것은 아니다. 매개변수의 자료형 및 개수가 다르면, 이는 함수 오버로
딩이 되어, 전달되는 인자에 따라서 호출되는 함수가 결정된다. 즉, 함수 오버로딩은 상
속의 관계에서도 구성이 될 수 있다.

*그렇기에 함수 오버라이딩이 되기 위해서는 부모, 자식 간에 같은 함수 이름, 매개변수를 가질 때 
발생하는 것이다.


















3. 정적 바인딩 VS 동적 바인딩 (가상 함수)
이번 주제는 부모와 자식이 동일한 메소드를 가질 때다.


*정리
--------------------------------------------------------
자료형 메소드 사용 -> 정적바인딩
객체 메소드 사용 -> 동적바인딩 (가상함수O)
--------------------------------------------------------


1) 정적 바인딩 (가상 함수 X)
*실행 이전에 값이 확정되면 정적 바인딩이라고 한다.
컴파일 타임에 호출될 함수가 결정되는 것으로, 함수는 기본적으로 정적 바인딩된다.
컴파일러는 선언되어있는 자료형을 보고 바인딩을 하기 때문에 실제로 가리키는 객체가 무엇이든 포인터의 자료형을 기반으로 호출의대상을 결정한다.
* 빌드 중에 이루어진다.  

[가상 함수 사용하지 않은 경우, 무조건 정적 바인딩 발생]
즉, 선언된 자료형을 기준으로 메소드가 호출됨
##########################################################################################
#include<iostream>

class animal {
public:
      void sound() {
        std::cout << "동물 소리를 내다." << std::endl;
    }
};

class Student : public animal {
public:
    void sound() {
        std::cout << "학생이 말을 합니다." << std::endl;
    }
};

int main() {

    Student* s1 = new Student(); // Student 클래스의 객체를 생성합니다. 
    s1->sound(); //학생이 말을 합니다.

    s1->animal::sound(); //동물 소리를 내다.


    animal* a1 = new animal(); // animal 클래스의 객체를 생성합니다.
    a1->sound(); // 동물 소리를 내다.

    animal* a2 = new Student(); // Student 클래스의 객체를 생성합니다. 
    a2->sound(); // 동물 소리를 내다.




    return 0;
}
##########################################################################################










2) 동적 바인딩
자료형이 어찌됐든 어떤 객체인지에 따라서 메소드를 호출할 거야!
-> 이경우 부모에 virtual을 명시해야함

*런타임에 호출될 함수가 결정되는 것으로, virtual 키워드를 통해 동적 바인딩하는 함수를 가상 함수라고 한다.
함수가 가상 함수로 선언이 되면, 포인터 변수가 실제로 가리키는 객체에 따라 호출의 대상이 결정된다.
* 실행 파일을 만들 때 바인딩 되지 않고 보류 상태 둔다.
* 실행 시간에 실제로 사용된 객체의 클래스형에 의해 호출될 함수가 결정됩니다.  
* 점프할 메모리 번지를 저장하기 위한 메모리 공간(4 byte)을 가지고 있다가 런타임에 결정.


--------------------------------------------------------------------------------
가상 함수 선언 방법

부모 함수에 virtual 붙여주면 됨
virtual void sound() {
	std::cout << "동물 소리를 내다." << std::endl;
}

-> 이렇게 하면 참조 자료형이 부모라도 객체가 자식이면 자식의 메소드가 호출됨
--------------------------------------------------------------------------------


##########################################################################################
#include<iostream>

class animal {
public:
      virtual void sound() {
        std::cout << "동물 소리를 내다." << std::endl;
    }
};

class Student : public animal {
public:
    void sound() {
        std::cout << "학생이 말을 합니다." << std::endl;
    }
};

int main() {

    animal* a1 = new animal(); // animal 클래스의 객체를 생성합니다.
    a1->sound(); // 동물 소리를 내다.

    animal* a2 = new Student(); // Student 클래스의 객체를 생성합니다. 
    a2->sound(); // 학생이 말을 합니다.


    return 0;
}
##########################################################################################










4. 순수 가상 함수와 추상 클래스
특정 클래스가 기초 클래스로 해당 기초 클래스로 객체를 만들어 사용하지 않을때 객체 생성을 막아야 한다.
이경우 virtual void display() = 0;으로 선언하여 해당 기초 클래스를 상속 받은 모든 클래스가 display를 구현하도록 하고 
기초 클래스로 객체를 생성하는 것을 막는다.

####################################################################################################################################################################################
basic 클래스는 객체를 생성하여 사용하지 않는 기초 클래스이다. 그렇기에 순수 가상함수를 통해 추상 클래스로 만들어보자
*basic 클래스에서 상위 클래스에서 공통적으로 정의할 display 함수를 순수 가상함수로 선언한다.
-> 1) basic 클래스로 객체를 생성할 경우 에러 발생
-> 2) 자식 클래스에서 순수 가상 함수를 구현하지 않을 경우 에러 발생
####################################################################################################################################################################################
#include <iostream>
#include <cstring>

class basic {
public:
    int basic_info;

    
    basic(int info) : basic_info(info) {};

    virtual void  display() = 0;


};

class application : public basic {
    char* application_name;

public:
    
    application(int info, const char* name) : basic(info) {
        application_name = new char[strlen(name) + 1]; 
        strcpy(application_name, name);
    }


    void display() {
        std::cout << "Basic Info: " << basic_info << std::endl;
        std::cout << "Application Name: " << application_name << std::endl;
    }

    ~application() {
    
        delete[] application_name;
    }


};

int main() {
    application myApp(123, "MyApp");

    myApp.display();

    //에러 발생
    //basic b1(10);


    return 0;
}

