[상속과 다형성]


1. 객체 포인터 변수
객체를 생성하는 방법은 총 2개이다.
1) Student s1
2) Student *s2 = new Student();

*2)번에 객체 포인터 변수에서 객체의 참조 자료형을 클래스 생성자가 상속하는 다른 부모 클래스로 변경할 수 있다.
-> Person *p = new Student();
이경우 Person 클래스에 정의된 멤버만 사용 가능하다. (자식 클래스 멤버 호출 불가)
즉, 포인터 형에 해당하는 클래스에 정의된 멤버에만 접근이 가능

=>

Penson *p = new Student()
-> Person 형의 포인터 변수 선언 = Student 객체 생성
즉, Student 객체를 Person 형 포인터 변수로 담아서 사용함

Student 형으로 객체를 만들었는데, Person 담는 포인터 변수에서 Student 멤버에 접근이 왜 불가능한가요?
-> C++에서는 객체의 형을 실제 가르키는 객체의 자료형이 아닌 포인터의 자료형으로 판단한다.
그렇기에 C++ 컴파일러에서는 포인터 자료형 이외의 멤버를 호출할 경우 에러를 발생시키는 것이다. 
(어? 너 클래스에 정의안된 멤버인데? 삡~ 에러)
##########################################################################################
#include<iostream>

class animal {
public:
	void breath() {
		std::cout << "숨을 쉽니다.";
	}
};

class Person : public animal{
public:
	void talk() {
		std::cout << "말을 합니다.";
	}
};


class Student : public Person{

public: 

	int age;
	Student() {
		age = 20;
	}
public:
	void study() {
		std::cout << "공부를 합니다.";
	}
};


int main() {
	
	Student* s1 = new Student();
	s1->breath();

	Person* p1 = new Student();
	p1->breath();
	//p1->study(); -> 에러


	animal* a1 = new Student();
	a1->breath();
	//a1->talk(); -> 에러
	//p1->study(); -> 에러
	
	std::cout << sizeof(*s1);
	std::cout << sizeof(*a1);
	
}

숨을 쉽니다.
숨을 쉽니다.
숨을 쉽니다.
4
1
##########################################################################################














2. 함수 오버라이딩 VS. 함수 오버로딩
기초 클래스와 동일한 이름의 함수를 유도 클래스에서 정의한다고 해서 무조건 함수 오
버라이딩이 되는 것은 아니다. 매개변수의 자료형 및 개수가 다르면, 이는 함수 오버로
딩이 되어, 전달되는 인자에 따라서 호출되는 함수가 결정된다. 즉, 함수 오버로딩은 상
속의 관계에서도 구성이 될 수 있다.

*그렇기에 함수 오버라이딩이 되기 위해서는 부모, 자식 간에 같은 함수 이름, 매개변수를 가질 때 
발생하는 것이다.


















3. 정적 바인딩 VS 동적 바인딩 (가상 함수)
이번 주제는 부모와 자식이 동일한 메소드를 가질 때다.


*정리
--------------------------------------------------------
자료형 메소드 사용 -> 정적바인딩
객체 메소드 사용 -> 동적바인딩 (가상함수O)
--------------------------------------------------------


1) 정적 바인딩 (가상 함수 X)
어떤 객체든 간에 나는 참조 자료형을 따라 갈거야!
즉, 자식과 부모의 함수가 동일한 게 있으면 선언된 자료형을 기준으로 메소드를 호출할거야!

[가상 함수 사용하지 않은 경우, 무조건 정적 바인딩 발생]
즉, 선언된 자료형을 기준으로 메소드가 호출됨
##########################################################################################
#include<iostream>

class animal {
public:
      void sound() {
        std::cout << "동물 소리를 내다." << std::endl;
    }
};

class Student : public animal {
public:
    void sound() {
        std::cout << "학생이 말을 합니다." << std::endl;
    }
};

int main() {

    Student* s1 = new Student(); // Student 클래스의 객체를 생성합니다. 
    s1->sound(); //학생이 말을 합니다.

    s1->animal::sound(); //동물 소리를 내다.


    animal* a1 = new animal(); // animal 클래스의 객체를 생성합니다.
    a1->sound(); // 동물 소리를 내다.

    animal* a2 = new Student(); // Student 클래스의 객체를 생성합니다. 
    a2->sound(); // 동물 소리를 내다.




    return 0;
}
##########################################################################################










2) 동적 바인딩
자료형이 어찌됐든 어떤 객체인지에 따라서 메소드를 호출할 거야!
-> 이경우 부모에 virtual을 명시해야함

*일단 컴파일러는 자료형을 보고 부모의 메소드를 호출하지만, 해당 자료형이 virtual이기에 실행시간에 실제 객체의 자료형을 보고 해당 메소드를 호출한다.
--------------------------------------------------------------------------------
가상 함수 선언 방법

부모 함수에 virtual 붙여주면 됨
virtual void sound() {
	std::cout << "동물 소리를 내다." << std::endl;
}

-> 이렇게 하면 참조 자료형이 부모라도 객체가 자식이면 자식의 메소드가 호출됨
--------------------------------------------------------------------------------


##########################################################################################
#include<iostream>

class animal {
public:
      virtual void sound() {
        std::cout << "동물 소리를 내다." << std::endl;
    }
};

class Student : public animal {
public:
    void sound() {
        std::cout << "학생이 말을 합니다." << std::endl;
    }
};

int main() {

    animal* a1 = new animal(); // animal 클래스의 객체를 생성합니다.
    a1->sound(); // 동물 소리를 내다.

    animal* a2 = new Student(); // Student 클래스의 객체를 생성합니다. 
    a2->sound(); // 학생이 말을 합니다.


    return 0;
}
##########################################################################################
