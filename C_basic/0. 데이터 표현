[4장 데이터 표현 방식의 이해]
[4-1 컴퓨터가 데이터를 표현하는 방식]
컴퓨터는 모든 데이터의 표현 및 연산을 2진수로 처리한다.
(1) 2진수, 10진수, 16진수란 무엇인가
2진수란 데이터를 표현하는데 두개의 숫자만 사용하겠다는 것이고, 10진수는 10개, 16진수는 16개라는 뜻이다.

[연습문제 4-1]
문제1) 10진수로 133을 2진수와 16진수로 표현해보자
2진수, 10000101
16진수, 85
8진수, 205

(2) 데이터 표현 단위인 비트와 바이트
비트는 컴퓨터가 나타낼 수 있는 최소 단위이며 2진수 값 하나 (0 or 1)을 저장할 수 있는 메모리 공간을 의미한다.
또한 이런 비트 여덟개가 모여서 바이트라는 데이터 단위가 구성된다.

[연습문제 4-2]
문제 1) 1바이트로 표현할 수 있는 데이터의 개수는 몇개인가?
> 255
문제 2) 11001110을 10진수로 표현하면? > 206

(3) 8진수와 16진수로 데이터 표현하기
C언어는 기본적으로 10진수이외에 8, 16진수도 허용된다. 즉 변수 선언후 값을 대입하는 경우 10진수로 표현해도되지만 8, 16 등 진수로 표현해도 문제없다.
혼동하지 말아야 할 것은 아래 초기화 문장은 완전히 동일한 문장이라는 것이다. 다만 숫자를 표현하는 방식이 다를 뿐이다.
a, b, c는 완전히 동일한 값을 가지고 있고 물론 컴퓨터 내부적으로는 2진수로 데이터가 저장되어있다.

####################################
#include<stdio.h>

int main(){

int a = 10; //10진수
int b = 0xa;//16진수 (0x로 시작)
int c = 012; //8진수 (0으로 시작)

printf("%d", c);
}

실행결과
10진수:10 16진수:a 8진수:12

####################################

[4-2 정수와 실수의 표현 방식]
(1) 정수의 표현 방식
int 형은 4바이트 공간을 이용하여 데이터를 표현하지만 1바이트 메모리 공간을 이용하여 정수의 표현 방식을 설명한다. (4바이트는 인간적으로 너무 기니깐 이해하기 쉽게 설명하기위해)

모든 정수의 가정 왼쪽에 있는 비트는 부호 비트이다. |0|0000000| 이런식으로 표현할 수 있다. 앞에 있는 0이 음수와 양수를 나타낸다.
양수면 0, 음수면 1로 표현된다.
음수를 표현할 때에는 2의 보수 체계를 기억해야 한다.
음수를 표현할 때는 음수로 표현할 수를 1의 보수를 취한 상태에서 1을 더한값이다.
즉, -5를 8비트로 표현하자면 |1|1111011|이다.
이래야지 +5와 -5를 더할때 0이된다. |0|0000101| |1|1111011|을 더하면
1|0|0000000|이된다. 여기서 올림수 1은 버려지기에 결국에 |0|0000000|가 된다.
[연습문제 4-3]
문제1) 10진수로 어떤 값을 의미하는지 쓰시오 (8비트로 정수를 나타낸다고 가정)
01001111 ->79
11110000 -> 00001111 -> 1 더하기 -> 00010000

(2) 실수의 표현 방식

컴퓨터가 실수를 표현하는 방식은 오차를 지닌다.
컴퓨터는 넓은 실수를 표현하기 위해 특정 공식을 대입하여 실수를 표현한다. 그 과정에서 정확하게 실수를 표현하지 못하여 이상한 값을 전달 할 수 있다.
[0.1 X 100을 하면 10이되어야하지만 10.000002이 출력된 것을 볼 수 있다]

##########################################
#include<stdio.h>

int main(){

float f = 0.0;

for(int a = 0; a < 100; a++){
f += 0.1;
}

printf("%f", f);
}

##########################################

[4-3 비트 단위 연산]
(1) & 연산자: 비트 단위 AND
& 연산은 두개의 비트가 모두 1일 때 1을 반환하는 연산이다.
0 & 0 -> 0
0 & 1 -> 0
1 & 0 -> 0
1 & 1 -> 1

##########################################
#include<stdio.h>

int main(){

int a = 11;
int b = 21;

/*
1011
10101
00001

*/

printf("%d", a&b);

}
실행결과: 1

##########################################

(2) or 연산자: 비트 단위 or | 연산은 두개의 비트 중 하나라도 1이면 1을 반환하는 연산이다. 다음은 | 연산자의 기본연산 형태를 보여준다.
0 | 0 -> 0 반환
0 | 1 -> 1 반환
1 | 0 -> 1 반환
1 | 1 -> 1 반환

##########################################
#include<stdio.h>

int main(){

int a = 11;
int b = 21;

/*
1011
10101
11111

*/

printf("%d", a&b);

}
실행결과: 31

##########################################

(3) ^ 연산자: 비트 단위 XOR

 ^ 연산자는 두개의 비트가 서로 다를 경우에 1을 반환하는 연산이다.
0 ^ 0 -> 0 반환
0 ^ 1 -> 1 반환
1 ^ 0 -> 1 반환
1 ^ 1 -> 0 반환

(4) ~ 연산자: 비트 단위 NOT 
보통 보수 연산이라고 해서 비트를 반전 시킨다.

##########################################
#include<stdio.h>

int main(){

int a = 11;
int b = ~a;
printf("%d", b);
}

결과: -12
11을 음의 보수를 취하고 1을 더한 후 -를 붙인 값, 즉 -12가 출력된다.

##########################################

(5) << >> 연산자: 비트 이동(shift)
비트를 이동시키는 연산자에는 두가지가 있다.
<< 연산자와 >> 연산자!

1. << 연산자
1) 양수일 때, a << b: a의 비트를 b칸씩 왼쪽으로 이동한 값 반환

##########################################
int a = 15;
printf("%d", a << 2);
//실행결과: 60 ##########################################

2) 음수일때, 오른쪽에 있는 0이 부호에 채워짐, 그래서 부호도 달라짐 ( - ) 에서 ( + )으로 변함

##########################################

int a = -2147483647;
printf("%d", a << 10);
//실행결과: 1024

##########################################

2. >> 연산자

1) 양수일때
오른쪽으로 원하는 만큼 이동하면 된다, 특별한건 없다.

#########################################
int a = 4;
printf("%d", a >> 1);
실행결과: 2

##########################################

2) 음수일때 짐
음수일때 비트연산자로 오른쪽으로 이동하면 앞에 음수를 나타내는 1도 오른쪽으로 이동하고 0이나 1로 부호를 나타내는 값도 채워진다.
우분투에서는 1로 왼쪽에 새롭게 채워진다

##########################################
int a = -4;
printf("%d", a >> 1);
실행결과: -2

##########################################


[5장 상수와 기본 자료형]
[5-1 C언어가 제공하는 기본 자료형]
변수라는 것은 데이터를 저장할 메모리 공간을 할당하고, 이에 이름을 붙여준것이라고 이미 정의하였다.
예를 들어서 정수를 저장할 메모리 공간 4바이트를 할당하고 나서 그 메모리 공간에 val이라는 이름을 붙여준다면 바로 val이 변수가 되는 것이다.

int val;
위 코드를 해석하자면 int 형으로 선언된 val은 4바이트 메모리 공간을 할당 받아서 정수를 저장할 수 있게 될 것이다.

(1) 기본 자료형 종류와 데이터 표현 범위

1) 정수형
char | 1바이트 | -128 ~ +127
short | 2바이트 | -32768 ~ +32767
int | 4바이트 | -2147483648 ~ +2147483647
*long은 32비트, 64비트 시스템에 따라 크기가 다르다
[32비트]
long | 4바이트 | -2147483648 ~ +2147483647
[64비트]
long | 8바이트 | -9,223,372,036,854,775,808 ~ +9,223,372,036,854,775,807

2) 실수형
float | 4바이트 | 3.4e-37 ~ 3.4e+38
double | 8바이트 | 1.7e-307 ~ 1.7e+308
long double | 8바이트 혹은 그 이상 | 차이를 많이 보임
[64 우분투 PC에서는 16바이트로 확인됨]

*왜 자료형을 나눠서 제공하는 것일까?)

1. 데이터의 표현 방식이 다르다.
정수형과 실수형 등 컴퓨터가 데이터를 처리하는 방식이 다르기 때문이다. 어떻게 다른지는 4장에서 확인

2. 메모리 공간을 적절하게 사용하게 위해
+- 10이라는 수만 사용할 때 char를 사용하게 되면 int를 사용할 때보다 3바이트를 더 적게 사용할 수 있다.

(2) sizeof 연산자를 이용한 자료형 크기의 확인
sizeof를 이용하여 자료형의 크기를 알아볼 수 있다.

###################################################
int a;
printf("%d", sizeof(a)); //a의 메모리 크기 출력
printf("%d", sizeof(int)); //int의 메모리 크기 출력

###################################################

(3) 자료형 선택하기

1) 정수형 데이터를 처리하는 경우)
예를 들어 사용자로부터 십의 자리수를 입력받아 출력하는 프로그램을 작성한다고 가정한다.
메모리의 낭비를 줄이기위해 char를 사용할 수도 있지만 일반적으로 그러지 않다.
컴퓨터는 내부적으로 int 형 데이터를 가장 빠르게 처리하기  char 대신 int를 사용한다. 일반적으로 char는 문자를 저장할 때 사용된다.

2) 실수형 데이터를 처리하는 경우)
컴퓨터가 실수형 데이터를 처리할 때 상당한 부담을 느낀다.
실수형을 선언할 때 한가지 선택의 지표가 되는 것은 정밀도이다.
위에서 실수를 표현할 때 기본적으로 오차가 존재한다고 말했는데  실수 자료형에서 소수점 몇째자리까지 오차없이 표현이 가능한 기준이 다르다.

[정밀도]
float | 소수 이하 6자리
double | 소수 이하 15자리
long double | double의 정밀도와 같거나 크다.

*그래서 일반적으로 뭐쓰는 게 좋을까?
-> double을 사용하는 것을 권장
float보다 정밀도가 높고 long double보다는 메모리를 덜 잡아서 그렇다고 함

*주의사항
double형을 받을 때는 반드시 %lf로 받아야함 (%f로 받으면 안됨)* 아래 예시 처럼 %lf로 받을 때 정상적으로 값을 받지만 %d로 받으니 값이 정상적으로 보이지 않았음음
(아래 1121은 double은 소수점 이하 15자리까지 정밀도를 보장하는데 이 정밀도를 초과해서 그럼)

###################################################

root@swhwang:/home/swhwang/바탕화면/study# cat test.c
#include <stdio.h>

int main() {
double a;
double b;
scanf("%lf", &a);
scanf("%f", &b);

printf("%.20f\n", a);
printf("%.20f\n", b);

return 0;
}

root@swhwang:/home/swhwang/바탕화면/study# ./test.out
3.123456789
3.123456789
3.12345678900000001121
0.00000000000000000000털
root@swhwang:/home/swhwang/바탕화면/study#

###################################################

(4) unsigned가 붙으면 표현의 범위가 달라진다
정수 기본자료형 앞에 unsigned를 붙이면 0보다 큰 값을 표현할 수 있는 범위가 두배가 된다.
왜냐면 +, -의 기준을 없애기 때문이다. (첫번째 부호비트를 부호를 나타내는 것이 아닌 값을 저장하기 위해서 사용되기 때문! -> 1비트가 더 붙으면 표현할 수 있는 수가 2배가 되기때문)

unsigned char | 1바이트 | 0 ~ 255
unsigned short | 2바이트 | 0 ~ 65,535
unsigned int | 4바이트 | 0 ~ 4,294,967,295
unsigned long | 8바이트 | 0 ~ 18446744073709551615

(5) 문자를 이용한 데이터의 표현과 자료형
컴퓨터는 문자를 어떻게 표현할까? 컴퓨터는 기본적으로 0,1만 인식할 수 있다.
그렇기에 문자를 표현하려면 숫자를 이용해야 한다.

ASCII 코드의 등장
숫자를 가지고 문자를 표현하기 위해서 숫자를 문자에 연결시키는 수밖에 없다.
A를 65로 표현하고 B를 66으로 표현하도록 약속을 한것이 ASCII코드이다.
문자는 char라는 자료형을 통해 저장할 수 있는데, 이 char의 범위는 -127 ~ 126까지 표현할 수 있다.
양의 정수만 본다면 0 ~ 126까지이고, 양수를 사용하여 총 127개를 사용가능하다.
그렇기에 ASCII 코드표를 보면 0 ~ 126까지 표현될 수 있는데 이것은 위의 char의 양수 범위 내에서 ASCII 코드로 문자와 숫자가 매치되어 사용하고 있는것을 확인할 수 있다.

정확히는 char는 정수형이다. 즉 문자를 저장하는 것이 아닌 숫자를 저장한다.
그렇기에 ASCII 코드와 매치되는 숫자를 저장하게 되는 것이다.

따라서 아래 코드를 실행했을 때 값은 '97'이 나온다.
printf("%d", 'a');

*그러면 정수는 int으로 선언하는 게 좋다면서? 왜 문자는 int형으로 저장하지 않아?
-> int형으로 선언하는 이유는 [연산]을 위함이다. 문자는 연산을 하지 않기에 char를 사용해도 문제가 없다.

[5-2 상수에 대한 이해]
상수는 크게 이름이 있는 상수와, 이름이 없는 상수로 바뉜다.

(1) 이름을 지니지 않는 상수 (리터럴 상수)

리털럴 상수의 선언
상수란 변경 불가능한 데이터를 의미하는 것이다.
int a = 30 + 40; 
위와 같은 코드에서 30 + 40을 a에 대입하기 위해서는 + 연산이 필요하다.
이 + 연산에서는 각 수가 메모리 상에 존재해야 한다. 그래야지 연산을 하기 때문이다.
연산은 CPU에서 진행되는데, 메모리에 존재하는 데이터들만 조작할 수 있기 때문이다.
위 과정의 세부적인 과정은 아래와 같다.
1) 30과 40 각각의 정수가 메모리 공간에 상수로서 저장된다.
2) 두 상수의 덧셈 연산이 진행된다.
3) 덧셈 결과가 변수 val에 저장된다.

위와 같이 30과 40이 메모리에 저장되는데 이때 이름이 없다.
이런 이름이 없는 상수를 리터럴 상수라고 한다.

그럼 상수를 저장할 때 자료형은 어떻게 인식하는 거죠?)
메모리에 리터럴 상수가 저장될 때 리터럴 상수의 자료형을 따로 정의하지 않아도 자동적으로 컴퓨터가 인식하여
리터럴 상수의 자료형이 결정된다.

-> 

그럼 내가 초기화하고자하는 변수의 자료형과 컴퓨터가 인식하는 리터럴 상수의 타입이 다르면 어떻하죠?) 접미사를 붙여주면 된다.
기본적으로 리터럴 상수를 인식할 때 [정수 -> int], [실수 -> double]로 인식한다.
즉 float a = 3.14;로 대입할 경우 경고 메시지를 확인할 수 있다.
warning: implicit conversion from 'double' to 'float' changes value from 3.14 to 3.140000104904175
(float 자료형에 double 형을 대입해서 데이터 정밀도가 손실될 수 있어라는 의미) -> double이 정밀도가 float보다 높기때문

위 에러를 해결하기 위해 컴파일러에게 이 리터럴 상수는 float이야!라는 걸 알려줘야 한다 방법은 아래와 같다.
(나는 이 실수를 float으로 인지하고 있어 -> 소수점 6자리 이후 정밀도가 떨어진다는 것을 인지하고 있어)

#######################################
float a = 3.14f; //접미사 f를 붙인다.

#######################################

[접미사]
1) U or U |unsigned int | 304U
2) I or L | long | 304L
3) ul or UL | unsigned long | 304UL
4) f or F | float | 3.15F
5) I or L | long double | 3.15L

(2) 이름을 지니는 상수: 심볼릭 상수
심볼릭 상수는 변수와 마찬가지로 이름을 지니는 상수이다.
심볼릭 상수를 표현하는 방법은 두가지가 있다.

1. const 키워드 사용

2. 메크로 이용 (26장에서 언급)

키워드를 통한 상수를 만들기
const int MAX = 100; //const는 우리가 알기 쉽게 대문자로 쓰는 것이 일반적이다.
규칙 1) 상수는 선언과 동시에 초기화해야 한다.
-> 구체적인 이유) 변수를 선언하고 초기화해주지 않으면 쓰레기 값으로 초기화가 되어있다.
이후 MAX  = 10으로 초기화하려고 하면 상수의 값 변경을 시도하기에 컴파에러가 발생하는 것이다.
규칙 2) 상수를 선언할 때 이름은 대문자로 표기하자 (변수와 상수를 구분하기 쉽게하기 위해서)

[5-3 자료형 변환에 대한 이야기]

*형변환의 종류
1) 묵시적 형변환: 컴파일러에 의해 자동적으로 발생하는 형 변환
2) 명시적 형변환: 프로그래머에 의해 명시적으로 형 변환

(1) 묵시적 형변환
대입 연산 시에 연산자의 왼쪽을 기준으로 자동형 변환이 발생한다.
따라서 대입연산자의 오른쪽에 존재하는 데이터가 왼쪽에 존재하는 데이터의 자료형으로 자동 형 변환된다.

#####################################
int n = 4.13;
printf("%d", n);
//결과: 4

float f = 4;
printf("%f", f);
//결과: 4.000000

#####################################

그럼 같은 자료형에 바이트 수가 다른 경우 어떻게 될까?
ex) int > char or char> int
-> 결론적으로 값의 표현 범위가 넓은 데이터로의 형 변환은 아무런 문제가 발생하지 않음. (char -> int)
문제가 발생하는 것은 표현 범위가 작은 데이터로의 형변환일 때 발생함 (int -> char)

[int -> char로 형 변환될 때 뒤에 1바이트를 제외한 앞부분이 손실됨] |0|0000000|00000000|00000000|10000000| ->  |10000000|
즉, 128를 char에 대입하면 |1|0000000|만 남기에 -128이 나옴

###################################################

root@swhwang:/home/swhwang/바탕화면/study# ./test.out 

-128root@swhwang:/home/swhwang/바탕화면/study# cat test.c 

#include <stdio.h>

int main() {

char a = 128;

printf("%d", a);

}

root@swhwang:/home/swhwang/바탕화면/study# ./test.out 

-128

###################################################ㄴ

정수의 승격
int형 연산이 빠르다고한 이유가 여기에 나와있다.
char a = 10;
char b = 20;
char c = a+b;
에서 a+b과정에서 a와 b 각각 int로 형변환되고 다시 char 변수 c에 담기게 된다.
int가 연산이 빠른이유는 int형으로 형변환을 하지 않아도 되기때문이다
산술 연산 과정에서의 형변환
산술 연산과정에서는 각 대상의 자료형이 일치해야한다. 즉, 7 + 1.4일 경우 7과 1.4의 타입이 일치해야한다.
이때 형변환은 데이터의 손실이 최소화되는 방향으로 진행된다.
1.4가 int형으로 변환시 데이터 손실 (0.4)가 발생하기에 자동적으로 데이터 손실이 없는 7을 double로 형변환하여 진행된다.
즉, 데이터 손실이 적도록 가장 넓은 범위를 가진 수의 자료형으로 맞춰서 연산이 된다.

(2) 명시적 변환
우선 명시적 형 변환을 사용해야 하는 예시를 보여주겠다.

##########################

printf("%f", 1/2);
//결과: 0

##########################

1을 2로 나누면 당연히 값은 0.5이다. 하지만 출력 결과는 0으로 나왔다.
*언제나 산술 연산결과의 자료형은 피 연사자의 자료형과 일치한다.
1과 2는 정수이기에 결과가 0으로 나온다. 여기서 0.5를 출력하기 위해서는 (float)를 사용하여 형을 변환시켜야 한다.

##########################

printf("%f", (float)1/2);
//결과: 0.500000

##########################
