[4. 고수준 파일 입출력]

저수준 파일 입출력은 바이트 단위로만 칩출력을 수행하므로 읽은 데이털르 가공하는 추가 작업이 필요함.
하지만 고수준 파일 입출력에는 "문자 단위", "행 단위", "버퍼 단위", 형식 기반 입출력" 등이 편리하게 제공하므로 프로그램에 맞게 사용 가능함.

#저수준 파일 입출력 시에는 파일 디스크립터(정수형)을 사용했지만, 고수준에서는 파일 포인터를 사용한다.




1. 파일 열기와 닫기


(1) 파일 열기, fopen()
File * fopen(const char *pathname, const char *mode)

* 두번째 인자인 mode 종류
r: 읽기 전용
w: 쓰기 전용, 기존 내용 삭제
a: 기존 내용의 끝에 추가해서 쓰기 용으로 텍스트 파일을 열음
rb: 읽기 전용으로 바이너리 파일을 열음
wb: 새로 쓰기 전용으로 바이너리 파일을 연다. 기존 내용은 삭제됨.
ab: 추가해서 쓰기용으로 바이너리 파일을 열음
?+: 읽기와 쓰기용으로 텍스트 or 바이터리 파일을 열음

(2) 파일 닫기, fclose()
int fclose()
파일 닫기를 정상적으로 완료하면 0, 오류가 발생하면 EOF(-1)를 return









2. 문자 기반 입출력
문자 기반 입출력의 함수에서는 저수준 처럼 바이트 단위로 입출력을 수행한다.


(1) 문자 단위 입력함수
아래 함수는 문자열 하나씩 읽고 오프셋을 하나씩 이동하여 while을 통해 읽을 수 있도록한다.
정수를 반환하는데 이는 아스키 코드에 매치되어 해당 문자 반환을 한다.
int fgetc(File *stream)
int getc(File *stream)
int getchar(void)
int getw(File *stream)

(2) 문자 단위 출력 함수
해당 정수의 값을 아스키 코드에 매치하여 파일에 쓴다.
int fputc(int c, FILE *stream)
int putc(int c, FILE *stream)
int putchar(int c)
int putw(int c, FILE *stream)


#############################################################################
#include <stdio.h>
#include <stdlib.h>
#include <stdlib.h>
#include <stdio.h>

int main() {
    FILE *rfp, *wfp;
    int c;

    rfp = fopen("hi.txt","r");
    wfp = fopen("bye.txt","r+");

    while((c = fgetc(rfp)) != EOF){
        printf("c의 정수 값: %d\n",c);
        printf("c의 문자 값: %c\n",c);
        fputc(c, wfp);

    }
}
[root@localhost ~]# ./a.out 
c의 정수 값: 104
c의 문자 값: h
c의 정수 값: 101
c의 문자 값: e
c의 정수 값: 108
c의 문자 값: l
c의 정수 값: 108
c의 문자 값: l
c의 정수 값: 111
c의 문자 값: o
c의 정수 값: 32
c의 문자 값:  
c의 정수 값: 119
c의 문자 값: w
c의 정수 값: 111
c의 문자 값: o
c의 정수 값: 114
c의 문자 값: r
c의 정수 값: 108
c의 문자 값: l
c의 정수 값: 100
c의 문자 값: d
c의 정수 값: 10 -> 개행문자이다. 파일에 자동으로 삽입되는 듯하다.
c의 문자 값: 

[root@localhost ~]# cat bye.txt 
hello world
#############################################################################


