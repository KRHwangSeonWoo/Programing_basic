[파일 다루기]

리눅스에서 파일의 정보는 inode에 저장되는데 파일의 종류, 접근 권한, 소유자의 UID, GID... 등 파일의 여러 정보가 담겨 있다.
inode의 정보를 검색하면 sys/stath 파일에 정의되어 있는 stat 구조체에 저장된다. 

1. 파일 정보 검색
int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);

2. 파일 접근 권한 함수

1) 파일 접근 권한 확인
int access(const char *pathname, int mode);

2) 파일 접근 권한 변경
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);

3. 링크 함수
int link(const char *oldpath, const char* newpath); 하드링크 생성
int symlink(const char *target, const char *linkpath); 실벌릭 링크 생성
int lstat(const char *pathname, struct stat *statbuf); 심벌릭 링크 정보 검색
ssize_t readlink(const char *pathname, char *buf, size_t bufsiz); 심벌릭 링크 내용 읽기
char *realpath(const char *path, char *resolved_path); 실밀릭 링크 원본 파일의 경로 검색
int unlink(const char *pathname); 링크 끊기






(1) 파일 정보 검색
stat의 st_mode을 출력할 때 파일 유형과 파일 권한을 더해서 출력해준다.

[파일 유형]
S_IFSOCK   0140000   socket
S_IFLNK    0120000   symbolic link
S_IFREG    0100000   regular file
S_IFBLK    0060000   block device
S_IFDIR    0040000   directory
S_IFCHR    0020000   character device
S_IFIFO    0010000   FIFO

+ 

[권한]

= 10644, 40666...
    

1. stat()
파일의 이름으로 정보를 검색한다.
가장 많이 쓰이는 함수이다.
성공시 0, 실패시 -1 반환한다.
파일의 정보를 검색할 때 읽기 이상의 권한이 꼭 없어도 된다. 해당 파일에 접근한 수 있도록 디렉터리에 권한만 있으면 충분하다.
############################################################################################################
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
   struct stat statbuf;

   if (stat("test.c", &statbuf) == 0) {
       printf("파일 이름: test.c\n");
       printf("파일 크기: %ld 바이트\n", statbuf.st_size);
       printf("팈일의 소유자 ID: %d\n", statbuf.st_uid);
       printf("파일의 그룹 ID: %d\n", statbuf.st_gid);
       printf("파일의 권한: %o\n", statbuf.st_mode);
   } else {
       perror("stat");
   }

   return 0;
}
[root@localhost ~]# ./a.out 
파일 이름: test.c
파일 크기: 528 바이트
팈일의 소유자 ID: 0
파일의 그룹 ID: 0
파일의 권한: 100644
############################################################################################################





2. fstat()
현재 열려있는 (open() 함수로 인해) 파일의 디스크립터를 받아 파일 정보를 검색한 후 stat 구조체에 저장한다.
############################################################################################################
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

int main() {
    int fd;
    struct stat statbuf;

    fd = open("test.c",O_RDONLY);

    if(fd == -1){
        perror("open: test.c");
    }

    fstat(fd, &statbuf);

    printf("Inode = %d", statbuf.st_ino);

   return 0;
}
[root@localhost ~]# ./a.out 
Inode = 16899233
############################################################################################################



#매크로를 이용한 파일 종류 검색
매크로 함수에 대한 설명 -> https://modoocode.com/99 참고
S_ISREG(), S_ISDIR() 등과 같은 매크로 함수로 쉽게 파일의 종류를 프로그래밍할 수 있다.
############################################################################################################
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

int main() {

	struct stat statbuf;
	int kind;

	stat("test.c",&statbuf);
	
	if(S_ISREG(statbuf.st_mode)){
		printf("일반 파일");
	}

	
	if(S_ISDIR(statbuf.st_mode)){
		printf("디렉터리");
	}


}
############################################################################################################






(2) 파일 접근 권한 검색


1. 상수를 이용한 파일 접근 권한 검색

파일 소유자(Owner) 권한:
S_IRUSR: 소유자 읽기 권한
S_IWUSR: 소유자 쓰기 권한
S_IXUSR: 소유자 실행 권한
S_IRWXU: 소유자 읽기, 쓰기 및 실행 권한 (위의 3개 상수를 OR 연산한 것)

파일 그룹(Group) 권한:
S_IRGRP: 그룹 읽기 권한
S_IWGRP: 그룹 쓰기 권한
S_IXGRP: 그룹 실행 권한
S_IRWXG: 그룹 읽기, 쓰기 및 실행 권한 (위의 3개 상수를 OR 연산한 것)

기타(Other) 권한:
S_IROTH: 기타 읽기 권한
S_IWOTH: 기타 쓰기 권한
S_IXOTH: 기타 실행 권한
S_IRWXO: 기타 읽기, 쓰기 및 실행 권한 (위의 3개 상수를 OR 연산한 것)
############################################################################################################
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>

int main(){
    struct stat statbuf;
    stat("hi.txt", &statbuf);

    printf("%o\n",statbuf.st_mode & S_IRGRP);

    if((statbuf.st_mode & S_IRGRP) != 0){
        printf("그룹의 읽기 권한 있음\n");
    }

      if((statbuf.st_mode & S_IXGRP) != 0){
        printf("그룹의 실행 권한 있음");
    }

}
[root@localhost ~]# ls -al | grep hi.txt 
-r--r--r--.  1 root    root     1192 Aug 29  2022 hi.txt
[root@localhost ~]# ./a.out 
40
그룹의 읽기 권한 있음
############################################################################################################

############################################################################################################
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    struct stat fileStat;
    const char *filename = "hi.txt";

    // 파일 정보 가져오기
    if (stat(filename, &fileStat) == -1) {
        perror("stat");
        return 1;
    }

    // 소유자 권한 확인 (읽기 및 쓰기)
    if ((fileStat.st_mode & S_IRUSR) && (fileStat.st_mode & S_IWUSR)) {
        printf("소유자에 대한 읽기 및 쓰기 권한이 있습니다.\n");
    } else {
        printf("소유자에 대한 읽기 또는 쓰기 권한이 없습니다.\n");
    }

    return 0;
}
############################################################################################################




2. access, 함수를 이용한 접근 권한 검색
int access(const char *pathname, int mode);
pathname의 파일이 mode의 권한을 가지고 있는지 확인하고 return함
***단 유효 사용자 ID(EUID)가 아닌, 실제 사용자 ID(RUID)에 대한 권한만 확인 가능 -> 코드를 실행한 사용자

RUID는 현재 프로세스가 시작될 때의 실제 사용자 ID를 나타냅니다. 즉, 프로세스를 시작한 사용자의 ID입니다.
EUID는 현재 프로세스가 현재 실행 중인 상태에서 사용하는 사용자 ID를 나타냅니다. 이것은 현재 권한을 나타내며, 파일 액세스 및 시스템 호출과 같은 작업에 영향을 미칩니다.

접근 권한이 있으면 0, 없으면 -1 return
F_OK는 파일의 존재여부, R_OK는 읽기 권함임
############################################################################################################
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h> // access 함수를 사용하기 위한 헤더 파일
#include <stdio.h>
#include <errno.h> // errno 변수와 ENOENT 상수를 사용하기 위한 헤더 파일
#include <string.h> // 오류 메시지 출력을 위한 헤더 파일

int main() {

    if (access("linux.bak", F_OK) == -1) {
        printf("linux.bak does not exist\n");
    }

    if (access("hi.txt", R_OK) == 0) {
        printf("읽기 권한 있음\n");
    }

    if (access("hi.txt", X_OK) == 0) {
        printf("실행 권한 있음1\n");
    }

    chmod("hi.txt", 0444);

    if (access("hi.txt", X_OK) == 0) {
        printf("실행 권한 있음2\n");
    }

    chmod("hi.txt", 0544);

    if (access("hi.txt", X_OK) == 0) {
        printf("실행 권한 있음3\n");
    }

    return 0;
}
[root@localhost ~]# chmod 444 hi.txt 
[root@localhost ~]# ./a.out 
linux.bak does not exist
읽기 권한 있음
실행 권한 있음3
############################################################################################################
                                                                                                                                                                 


(3) 파일의 접근 권한 변경


1. chmod
int chmod(const char *filepath, mode_t mode);
############################################################################################################
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>

int main(){
    chmod ("hi.txt", 0777); 
}
############################################################################################################



2. fchmod, 파일 기술자로 접근 권한 변경
############################################################################################################
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h> // open 함수와 파일 모드 플래그를 사용하기 위한 헤더 파일
#include <stdio.h>
#include <unistd.h> // fchmod 함수를 사용하기 위한 헤더 파일

int main() {
    int fileint;
    FILE *file;

    fileint = open("hi.txt", 0666); // 파일을 열고 파일 모드를 지정
    if (fileint == -1) {
        perror("open");
        return 1;
    }

    fchmod(fileint, 0666); // 파일의 권한을 변경
    // 파일을 사용한 후, 파일 디스크립터를 닫아주는 것이 좋습니다.
    close(fileint);

    return 0;
}
############################################################################################################
