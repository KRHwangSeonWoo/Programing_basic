[1. C++으로의 전환]


1. printf와 scanf를 대신하는 입출력

데이터의 입출력 시 데이터 포맷 지정이 필요 없음 (포맷 스트링이 필요없음)


(1) 문자열 Hello world의 출력

############################################################
#include<iostream>
int main(void) {
	std::cout << "Hello World" << std::endl;
	std::cout << "Hell " << "World!" << std::endl;
	std::cout << "Hell " << "World!";
	std::cout << "Hell " << "World!";
}
실행 결과:
Hello World
Hell World!
Hell World!Hell World!
############################################################

#관찰 포인트

1) 헤더 파일 선언문 #include<iosstream>
std, cout, endl와 같은 것을 선언하기 위해서는 위의 헤더 파일 선언문이 추가되어야 함.
또한 표준 헤더 파일에서는 확장자를 생략하기로 약속했다!!!

2) std::cout와 << 연산자를 이용한 출력
C에서는 %d, %s로 출력 포맷을 지정했다. 하지만 위 출력 방식은 C언어보다 편리함
std::cou, <<, std::endl이 제대로 어떤 의미 인지 알기위해서는 진도를 나가야 한다고 한다.

3) <<의 연이은 출력과 개행
std::cout <<"출력대상" <<"출력대상" <<std::endl와 같이 연이은 출력과 개행이 가능함
\n로도 개행이 가능하긴 하다. 하지만 가독성이 떨어져보임





(2) scanf를 대신하는 데이터의 입력

############################################################

#include<iostream>

int main(void) {
	int num1;
	std::cout << "숫자 입력";
	std::cin >> num1;
	std::cout << num1 << std::endl;


	char str[30];
	std::cout << "문자열 입력";
	std::cin >> str;
	std::cout << str << std::endl;


	int num2;
	std::cout << "숫자 입력";
	std::cin >> num2;
	std::cout << num2 << std::endl;
}
실행 결과:
숫자 입력1
1
문자열 입력hello
hello
숫자 입력1.3
1
############################################################

#관찰 포인트

1) 데이터 입력에 사용되는 std::cin과 >> 연산자
C++에서 데이터의 입력도 데이터의 출력과 마찬가지로 별도의 포맷 지정이 필요없다.
그렇기에 int 형으로 선언한 자료형을 int로 사용하고 싶으면 int로 선언하고 double로 사용하고 싶으면 double로 받으면 된다.
std:cin >> num1 >> num2와 같이 한번에 여러개를 받을 수 있고 공백 및 Enter로 나누어짐

2) 문자열 입력도 마찬가지로 std::cin >> str로 사용하면 된다.

3) std::cin >> nul에서 int형에 1.3을 입력했을 때  생기는 현상
아래 결과와 같이 1.3\n을 입력했을 때 .3이 str이 입력되고 출력됨을 확인할 수 있다.
입력 버퍼에서는 키보드로 입력한 정보가 입력 버퍼에 저장되는데 이때 1.3\n을 입력 시 입력 버퍼의 있는 데이터 중에서 int형에서 저장할 데이터인 1만 읽고 나머지는 내버려둔다. 
즉 .3\n이 입력 버퍼에 남게되고 std::cin >> str; 코드에서 .3\n을 읽게되어 바로 .3이 출력되는 것이다.

***
그럼 1.3에서 .3을 읽을 때 오류가 나서 1만 읽고 1만 버퍼에서 삭제하고 나머지 .3은 남아있는거야?

ChatGPT
네, 맞습니다. std::cin에서 정수형 변수에 실수 값을 입력하면 오류가 발생하며, 입력 버퍼에는 오류가 발생한 시점까지의 데이터만 남게 됩니다. 예를 들어, 사용자가 "1.3"을 입력한 경우:

std::cin >> num1;에서는 실수값 "1.3"을 정수형 변수 num1에 입력하려고 시도합니다.
그러나 정수에 실수를 입력하면 변환이 불가능하므로 std::cin.fail()이 true가 됩니다.
입력 버퍼에는 "1.3"에서 "1"까지만 남게 됩니다. 소수점 이후의 ".3"은 입력 버퍼에 남아 있습니다.
이후에 다른 입력을 받을 때, 이전 입력에서 남아있는 ".3"이 올바른 입력으로 처리되지 않을 수 있습니다. 따라서 추가적인 처리 없이 다음 입력을 받을 경우에 문제가 발생할 수 있습니다. 이때는 std::cin.ignore()를 사용하여 입력 버퍼를 명시적으로 비워주는 것이 좋습니다.

############################################################
#include<iostream>

int main(void) {
	int num1;
	std::cout << "숫자 입력";
	std::cin >> num1;

	std::cout << num1 << std::endl;


	char str[30];
	std::cout << "문자열 입력";
	std::cin >> str;

	std::cout << str << std::endl;
}
숫자 입력1.3
1
문자열 입력.3

############################################################    

[번외로 배열을 생성하면 다 NULL로 채워지는 듯하다]
############################################################    
#include<iostream>

int main(void) {
    char str[100] = "hi";
    std::cout << str << std::endl;
    str[3] = 'c';

    std::cout << str << std::endl;

}
출력 결과:
hi
hi
############################################################   














2. 함수 오버로딩
C에서는 함수의 이름이 동일한 것이 있는 것을 허용하지 않음
하지만 C++에서는 그렇지 않음
매개변수를 보고서 특정 함수에 매칭 시켜주기도 함

############################################################   
#include<iostream>

void Func1() {
	std::cout << "Func1 called" << std::endl;
}

void Func1(int a) {
	std::cout << "Func" << a <<"called" << std::endl;
}

int main(void) {
	Func1();
	Func1(3);

}
실행결과:
Func1 called
Func3called
############################################################




(1) 매개 변수의 디폴트 값
C++에서는 디폴트 값을 설정할 수 있다.
인자값이 전달되지 않으면 디폴트로 함수에서 정해놓을 수 있다.
############################################################

#include<iostream>

void Func1(int a = 1, int b = 2) {
	std::cout << a  << b << std::endl;
}

int main(void) {
	Func1();
	Func1(3);
	Func1(3,4);


}
실행결과:
12
32
34
############################################################




(2) 디폴트 값은 함수의 선언 부분에만 표현 가능
함수 선언 후 구현을 한다고 하면 선언 부분에 디폴트 값을 넣을 수 있고, 구현에서는 표현할 수 없다. (개발자 개발 방법론상)(3

[좋지 않은 예]
컴파일 상 문제는 없어보이나, 기본적으로 함수의 선언 - main - 정의 순으로 개발하도록 되어있는 듯하다.
그렇기에 아래의 순서는 개발자의 프로토콜을 깨는 프로그래밍 방법이라고 할 수 있을 듯하다.
############################################################
#include<iostream>

void Func1(int a, int b);
void Func1(int a = 1, int b = 2) {
	std::cout << a << b << std::endl;
}

int main(void) {
	Func1();
	Func1(3);
	Func1(3,4);


}
실행결과:
12
32
34

############################################################



[오류]
심각도	코드	설명	프로젝트	파일	줄	비표시 오류(Suppression) 상태
오류	C2660	'Func1': 함수는 0개의 인수를 사용하지 않습니다.	Project3	C:\C\C 기초\소스 코드\Project3\Project3\Project3.cpp	9	
오류	C2660	'Func1': 함수는 1개의 인수를 사용하지 않습니다.	Project3	C:\C\C 기초\소스 코드\Project3\Project3\Project3.cpp	10	
############################################################
#include<iostream>

void Func1(int a, int b) {
	std::cout << a << b << std::endl;
}


int main(void) {
	Func1();
	Func1(3);
	Func1(3,4);


}
void Func1(int a = 1, int b = 2);
############################################################


[정상 동작]
############################################################
#include<iostream>

void Func1(int a = 1, int b = 2);

int main(void) {
	Func1();
	Func1(3);
	Func1(3,4);


}

void Func1(int a, int b) {
	std::cout << a << b << std::endl;
}
실행결과:
12
32
34
############################################################



(3) 



