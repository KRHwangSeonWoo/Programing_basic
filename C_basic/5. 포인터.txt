[포인터]


1. 포인터 기초
포인터는 메모리의 부여된 주소를 나타냄, 주소 "값"을 나타낼 때는 포인터 상수라고 하고 주소를 저장할 수 있는 "변수"를 나타낼 때는 포인터 변수라고 함
포인터 변수의 선언과 사용은 아래와 같다.

& -> 변수 주소 값 줄게!
* -> 주소에 있는 값을 가르킬거야! but 선언 시는  포인터 변수를 선언할 거야!
* 없이 -> &변수의 주소

int *p (선언 시니깐 p는 포인터 변수야!!) = &a(a의 주소값을 줄게!); 
printf("%p", p); -> *없이 그냥 p니깐 a의 주소값 출력
printf("%d", *p); -> a 변수의 주소에 있는 값을 출력



int a = 1;
int *b = &a;
위에 *b는 간접참조 연산자로 사용된다. b는 a의 주소값을 가르키고 a의 주소는 데이터 1을 가르킨다. 즉 *b + 1을 하면 값은 2가 나오게 된다.
*b + 1과 a + 1은 같다.
################################################################################################################################################
#include <stdio.h>

int main() {

	int a = 1;
	
	int* b = &a;
	printf("%d", *b + 1);
	//2

	printf("%d", b + 1);
	//-1851786360 -> 정상적인 값이 안나옴


}
################################################################################################################################################

################################################################################################################################################
#include <stdio.h>
#include <string.h>

int main() {

	int a = 10;
	//int b = &a; -> 에러
	//int* b = a; -> 에러

}
################################################################################################################################################

################################################################################################################################################
#include <stdio.h>


int main() {
    int a[3] = { 1,2,3 };
    int* b = a;
    printf("%d", b[2]);
    //3

    return 0;
}
################################################################################################################################################



(1) 포인터 제1법칙 : 주소 연산자와 간접참조 연산자 사이의 법칙
*와 &결합 순서는 우측에서 좌측 순서이다. 또한 *(& a) = a이다, 즉 a의 주소 값을 *로 지정하면 값을 return하게 된다.
이렇게 하기 싫으면 먼저 연산하고 싶은 것은 ( )로 묶어주자!
################################################################################################################################################
#include <stdio.h>

int main() {
	int a = 10;
	
	int* ptr = &a;

	printf("%d", *ptr);//10

	printf("%d", *&a);//10


}
################################################################################################################################################















(2) 포인터 인수 전달
두 변수의 값을 바꾸는 프로그램


아래와 같이 하면 값이 바뀌지 않는다 swap에서 사용하는 변수는 인자값으로 a, b의 값만을 할당했을 뿐,
지역변수로 main함수에 정의된 a, b 변수와는 관련이 없다.
################################################################################################################################################
#include <stdio.h>

void swap(int a, int b) {

	int tmp = a;

	a = b;

	b = tmp;

}

int main() {

	int a = 10;
	int b = 20;

	swap(a, b);

	printf("%d\n %d", a, b);
	//10
	//20
}
################################################################################################################################################


아래와 같이 메모리 주소같을 이용해 값을 바꿔줄수있다.
################################################################################################################################################
#include <stdio.h>

void swap(int *a, int* b) {

	//인자 값으로 a, b의 주소 값을 받고
	int tmp = *a; //a가 가르키고 있는 변수의 주소의 값을 tmp에 저장

	*a = *b; //main 함수 변수 b의 주소가 가르키는 값을 *a에 저장 (*a는 main함수의 a 변수의 데이터를 가지고 있는 주소의 값을 의미)

	*b = tmp; //tmp(*a)가 가르키는 값을 *b 저장 (*b는 main함수의 b 변수의 데이터를 가지고 있는 주소의 값을 의미)

}

int main() {

	int a = 10;
	int b = 20;

	swap(&a, &b);

	printf("%d\n %d", a, b);
	//20
	//10
}
################################################################################################################################################
































































2. 배열과 포인터
배열 이름은 주소이므로 포인터 상수이다. -> 변수 그자체가 주소값을 가르킨다.
즉 int a[] = {1,2,3}으로 선언하고 int *p = a;로 하여야 한다. (& 이거를 붙이지 않고)
***아래에 printf("%s", p);로만하는 이유(*p가 아닌 이유)는 %s가 문자열(배열)을 나내는 포맷 스트링인데 %s 로직 상 전달 받은 주소(배열 변수)안에 주소 값을 가르키는 *가 내재되어
있어 그럴 수도 있겠다는 추측이 듦. (%d.........인 경우는 *p를 사용했었음) -> 문자열 출력 시 *p로 하면 에러가 발생
################################################################################################################################################
#include <stdio.h>

	int main() {

		char str[] = "hello world";
		char* p = str;

		printf("%s\n", str);
		printf("%s", p);
		/*
hello world
hello world
		*/
	
	
}
################################################################################################################################################













1) 포인터에 대한 가감 연산
포인터를 일정한 정수만큼 증가시키거나 감소시키면 그 포인터가 가르키는 대상의 크기(int -> 4, char -> 1)의 배수만큼 증감됨. 즉 sizeof(int....) 만큰 증감
예를 들면 int a[] = {1,2,3};     int* ptr = a;하면  ptr + 1은 -> 2 return
################################################################################################################################################
#include <stdio.h>

int main() {

	int a[] = { 1,2,3 };
	
	int* ptr = a;

	printf("%p\n", ptr);
	printf("%p\n", ptr+1);
	printf("%p", ptr+2);
/*
00000021BA72F528
00000021BA72F52C
00000021BA72F530
*/


	printf("%d\n", *(ptr));
	printf("%d\n", *(ptr + 1));
	printf("%d", *(ptr + 2));
/*
1
2
3
*/


}
################################################################################################################################################




################################################################################################################################################
#include <stdio.h>

int main() {

	char a[] = "hihi";

	char* ptr = a;

	printf("%p\n", ptr);
	printf("%p\n", ptr + 1);
	printf("%p\n", ptr + 2);
	/*
00000064521EF7C4
00000064521EF7C5
00000064521EF7C6
	*/


	printf("%c\n", *(ptr));
	printf("%c\n", *(ptr + 1));
	printf("%c", *(ptr + 2));
	/*
h
i
h
	*/
}
################################################################################################################################################



























2) 포인터를 통한 배열 원소 참조
배열의 포인터를 이용한 문자열 출력하기
################################################################################################################################################
#include <stdio.h>
#include <string.h>

int main() {

	char str[] = "i'm king";

	for (int i = 0; i < strlen(str); ++i) {
		putchar(str[i]);
		//i'm king
	}

	for (int i = 0; i < strlen(str); ++i) {
		putchar(*(str+i));
		//i'm king
	}


}
################################################################################################################################################






3) 배열 매개변수는 사실 포인터 변수
함수에서 배열 형태로 매개 변수를 받는다는 것은 해당 배열의 "값"을 받아오는 것이 아닌, 포인터 즉 주소를 받아오는 것이다.
그렇기에 함수 내에서 값을 다르게 주면, 외부에 선언했던 배열의 값도 달라질수있으니 유의하자.
또한 매개변수를 받을 떄 int *ptr, int ptr[] 이렇게 두개로 받을 수 있으니 참고하자.
################################################################################################################################################
#include <stdio.h>
#include <string.h>

void arr(int *ptr) {
	ptr[0] = 123;
}

void arr2(int ptr[]) {
	ptr[0] = 456;
}



int main() {

	int a[] = { 1,2,3 };
	printf("%d\n", a[0]);
	//1

	arr(a);
	printf("%d\n", a[0]);
	//123

	arr2(a);
	printf("%d", a[0]);
	//456


}
################################################################################################################################################



################################################################################################################################################
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <errno.h>
#include <string.h>

int hi(char hi[]/*const char* hi도 가능*/) {
	printf("%s", hi);

	return 0;
}

int main(char * argv[]) {

	char ef[3] = "be";
	hi(ef);

}
################################################################################################################################################




































3. 이중 포인터
포인터는 주소값을 가지고 있는데, 이 주소값을 가지고 있는 주소를 가르키는 포인터가 있다, 이것이 이중 포인터이다.
이중 포인터의 최초 변수 값을 구하기 위해서는 **ptr을 사용하는데 *(*ptr)이라고 이해하면 된다.
################################################################################################################################################
#include <stdio.h>
#include <string.h>

void arr(int *ptr) {
	ptr[0] = 123;
}

void arr2(int ptr[]) {
	ptr[0] = 456;
}



int main() {

	int a = 10;

	int* ptr = &a;

	int** pptr = &ptr;

	printf("%d", **pptr);
	//10

	printf("%p", *pptr);
	//0000000022CAFFBE4 -> ptr의 주소값 반환



}
################################################################################################################################################







































4. 포인터 배열과 배열 포인터

[포인터 배열 vs 배열 포인터]

포인터 배열 -> 요소로 주소 값을 가지고 있는 포인터
배열 포인터 -> 배열 전체를 가르키는 포인터
-> 배열 포인터는 2차원 배열에서 많이 쓰임


포인터 배열

▶ 포인터 들의 배열이다.
 배열의 요소가 포인터들로 이루어져 있다.
▶ 선언방법 : char* arr[3]; 
배열 요소의 자료형이 char* (포인터)인 배열

그 배열의 요소의 개수가 3개.
int* a[3];는 int 형 변수의 주소 값을 담을 포인터 배열 변수 3개를 만든다는 것이다.
쉽게 풀어서 표현하면 int* (a[3])임.
각 포인터 별로 배열의 요소든, 일반 변수든 간에 각각 주소값을 저장하면 포인터 배열!

################################################################################################################################################
#include <stdio.h>
int main() {

	int* a[3];
	//정수형 변수의 주소값을 담을 3개의 포인터 변수 배열을 선언함
	int b = 999;

	a[0] = &b;
	printf("%d\n", *a[0]);
	//999

	printf("%p\n", a[0]);
	//000000DF7416F4C4

	int num[] = { 1,2,3 };
	int* ptr3[3] = { &num[0], &num[1], &num[2] };
	printf("%d", *ptr3[1]);
	//2


	int d[2] = { 1,2 };
	printf("%d\n", d[0]);
	//1

	int c = 10;
	int* ptr = &c;
	printf("%d", *ptr);




}
################################################################################################################################################








배열 포인터

char (*arr)[3];
배열 포인터란 배열을 가리킬 수 있는 '포인터'를 의미합니다.
1차원 배열은 이름 자체가 포인터이기 때문에 배열 포인터가 필요없습니다. 하지만 2차원 배열은 이름 자체로 포인터의 역할을 할 수 없습니다.
배열 포인터를 사용하는 이유는 2차원 이상의 배열을 가리킬 때 포인터를 배열처럼 사용하기 위함입니다.
따라서 배열 포인터는 2차원 이상의 배열에서만 의미를 가집니다.

다음 예제는 배열 포인터를 사용하여 배열과 같은 인덱싱 방법으로 배열 요소를 참조하는 예제입니다.
포인터에 배열명을 저장하면 배열 포인터를 2차원 배열처럼 쓸 수 있습니다

앞서 1차원 배열에서 arr[i] == *(arr+i) 라는 문장이 성립한다고 했습니다. 마찬가지로 2차원배열에서도 arr[i] == *(arr+i) 입니다.
아래 수식들은 모두 같은 표현입니다.

arr[i][j]	*(arr+i)[j]	*(arr[i]+j)	*(*(arr+i)+j)
################################################################################################################################################
#include <stdio.h>
 
int main(void)
{
    int arr2d[2][3] = {
    {10, 20, 30},
    {40, 50, 60},
    };
 
    int i, j;
 
    int (*ptr)[3] = arr2d;    // 배열 포인터 선언
 
    for (i = 0; i < 2; i++)
    {
        for (j = 0; j < 3; j++)
            printf("%d ", ptr[i][j]);    // 배열 포인터로 참조
        printf("\n");
    }
 
    return 0;
}
################################################################################################################################################


################################################################################################################################################
#include <stdio.h>

void printArray(int a[]) {
    printf("%d", a[0]);
}

void printMultiArray1(int arr[][3], int rows) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < 3; ++j) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}


void printMultiArray2(int(*arr)[3], int rows) {
//인자값 int (*arr)[3]은 배열 인덱스 개수 3마다
이차원배열의 하나의 행으로 끊어서 인식
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < 3; ++j) {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
}


int main() {

    int arr[2] = { 1, 2 };
    printArray(arr);

    int arr1[2][3] = { {1, 2, 3}, {4, 5, 6} };

    printMultiArray1(arr1, 2);
    printMultiArray2(arr1, 2);
/*
11 2 3
4 5 6
1 2 3
4 5 6
*/

return 0;
}
################################################################################################################################################






5. 포인터를 이용한 typedef

typeof를 이용하여 자료형은 커스텀하게 할수있다.
################################################################################################################################################
#include <stdio.h>

int main() {

	typedef int* a;
	int b = 10;
	a c = &b;
	printf("%d", *c);

}
################################################################################################################################################

























6. void 포인터
void 포인터는 int, char 등 여러 자료형을 담을 수 있는 포인터이다.
대신 void 포인터는 간접 참조를 하지 못함. 간접 참조하려면 다른 포인터 형으로 형변환을 수행해야 함.
################################################################################################################################################
#include <stdio.h>

void print(void *age) {
	printf("%p\n", age);
	//0000001904F5FB34
	
	//printf("%d", *age); 에러남
	//값을 가져올려면 아래와 같이 사용해야 함.

	printf("%d", *(int*)age);
	//10
}

int main() {
	int a = 10;

	print(&a);


}
################################################################################################################################################



	








7. 함수 포인터
################################################################################################################################################
#include <stdio.h>

void fun(int a, int b, int (*f1)(int, int)) {
	printf("%d", f1(a, b));

}

int add(int a, int b) {
	return a + b;
}

int min(int a, int b) {
	return a - b;
}

int main() {
	int a = 10;
	int b = 20;
	//&붙여도 되고 안해도 됨
	fun(a, b, &add);
	//30
	fun(a, b, min);
	//-10

}


################################################################################################################################################



	


