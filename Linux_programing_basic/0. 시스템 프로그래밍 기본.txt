[시스템 프로그래밍 기본]




1. 컴파일 환경
작성한 프로그램을 실행하기 위해서는 컴파일을 해야한다. 컴파일이란 텍스트로 작성한 프로그램을 시스템이 이해할 수 있는
기계어로 변환하는 과정이다.

컴파일의 과정의 아래와 같다.
test.c는 printf 함수만 사용한다는 것을 가정

test.c(소스코드) -> test.o(소프 파일을 컴파일한 파일 -> 오브젝트 파일 -> 링크 ) -> test.o + printf.o -> a.out(실행 파일)

오브젝트 파일과 실행 파일의 차이점

오프젝트 파일 (Object File):

오프젝트 파일은 소스 코드를 컴파일한 결과물 중 하나입니다.
컴파일러는 소스 코드를 기계어나 중간 언어로 번역한 후, 이를 오프젝트 파일 형식으로 저장합니다.
여러 소스 파일을 컴파일한 경우 각각의 소스 파일에 대한 오프젝트 파일이 생성됩니다.
오프젝트 파일은 아직 완전한 실행 코드가 아니며, 라이브러리 함수나 다른 오프젝트 파일과 링크하여 실행 파일을 생성하는 과정이 필요합니다.
실행 파일 (Executable File):

실행 파일은 컴파일된 소스 코드와 필요한 라이브러리 및 리소스가 모두 포함된 완전한 프로그램입니다.
컴파일러나 링커(Linker)가 여러 오프젝트 파일과 라이브러리를 결합하여 실행 파일을 생성합니다.
실행 파일은 컴퓨터에서 직접 실행할 수 있으며, 프로그램의 동작을 시작하는 역할을 합니다.

컴파일러나 링커(Linker)가 여러 오프젝트 파일과 라이브러리를 결합하여 실행 파일을 생성합니다.







(1) GNU C 컴파일러: gcc
프로그램을 컴파일하려면 이를 수행하는 컴파일러가 설치되어 있어야 함
리눅스에는 gcc가 존재

-c 옵션: 오브젝트 파일만 생성
-o 실행 파일 명: 지정한 이름으로 실행하일을 생성한다. 기본 실행 파일명은 a.out이다.

default로 out 파일 생성
[root@localhost ~]# gcc hi.c
[root@localhost ~]# ls
a.out  hi.c

out 파일의 이름 지정
[root@localhost ~]# gcc -o bye.out hi.c
[root@localhost ~]# ls
bye.out  hi.c






(2) makefile과 make
대부분의 프로그램은 소스 파일 여러개로 구성되고 컴파일 할 때 이를 묶어서 하나의 실행파일을 생성함.
리눅스에서는 여러개의 .c 파일을 컴파일하고 링크하여 하나의 실행파일로 생성하는데 이때 makefile과 make 명령어를 사용함.


###############################################################################################################################################################################
#Makefile
# Makefile for building hi.c and print.c into result.out

# Compiler
CC = gcc

# Compiler flags
CFLAGS = -Wall

# Source files
SRC_HI = hi.c
SRC_PRINT = print.c

# Output executable name
OUT = result.out

# Default target
all: $(OUT)

# Build result.out from hi.c and print.c
$(OUT): $(SRC_HI) $(SRC_PRINT)
        $(CC) $(CFLAGS) -o $(OUT) $(SRC_HI) $(SRC_PRINT)

# Clean up
clean:
        rm -f $(OUT)

# Define "make clean" as a phony target
.PHONY: clean
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[root@localhost ~]# cat hi.c
#include<stdio.h>

extern int hi();

int main()      {

hi();
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[root@localhost ~]# cat print.c
void hi(){

printf("hi");

}
###############################################################################################################################################################################

[root@localhost ~]# make
gcc -Wall -o result.out hi.c print.c
hi.c: In function ‘main’:
hi.c:8:1: warning: control reaches end of non-void function [-Wreturn-type]
 }
 ^
print.c: In function ‘hi’:
print.c:3:1: warning: implicit declaration of function ‘printf’ [-Wimplicit-function-declaration]
 printf("hi");
 ^
print.c:3:1: warning: incompatible implicit declaration of built-in function ‘printf’ [enabled by default]
[root@localhost ~]# ls
hi.c  Makefile  print.c  result.out
















(3) 오류 처리함수

#오류 발생시 return 값
시스템 호출 오류 발생시 -> -1
라이브러리 함수 -> NULL


1) errno 상수
-> 상수만으로는 의미를 파악하기는 어려움
###############################################################################################################################################################################
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <errno.h>
#include <string.h>

int main() {
    FILE* file;

    // 파일 열기 시도
    file = fopen("non_existent_file.txt", "r");

    if (file == NULL) {
        // 파일 열기가 실패했을 때 errno 값을 확인하여 오류 메시지 출력
        printf("파일 열기 오류: %d\n", errno);

        // 예외 처리 또는 다른 작업 수행
    }
    else {
        // 파일 열기가 성공했을 때 파일 작업 수행
        // ...

        // 파일 닫기
        fclose(file);
    }

    return 0;
}
 }

    return 0;
}
###############################################################################################################################################################################
파일 열기 오류: 2





2) perror() 함수
가공이 불가능하지만 빠르고 단순하게 오류 메시지를 보여준다.

################################################################################################################################################################################define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <errno.h>
#include <string.h>

int main() {
    FILE* file;

    // 파일 열기 시도
    file = fopen("non_existent_file.txt", "r");

    if (file == NULL) {
       
        perror("file");

        // 예외 처리 또는 다른 작업 수행
    }
    else {
        // 파일 열기가 성공했을 때 파일 작업 수행
        // ...

        // 파일 닫기
        fclose(file);
    }

    return 0;
}
###############################################################################################################################################################################
file: No such file or directory







3) strerror()
오류 커스터 마이징 가능
###############################################################################################################################################################################
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include <errno.h>
#include <string.h>

int main() {
    FILE* file;
    char* error;
    // 파일 열기 시도
    file = fopen("non_existent_file.txt", "r");

    if (file == NULL) {
       
        error = strerror(errno);
        printf("file errer %s", error);
        // 예외 처리 또는 다른 작업 수행
    }
    else {
        // 파일 열기가 성공했을 때 파일 작업 수행
        // ...

        // 파일 닫기
        fclose(file);
    }

    return 0;
}
###############################################################################################################################################################################
file errer No such file or directory









(4) 동적 메모리 할당 





1) malloc()
동적으로 메모리를 할당하고 메모리 할당에 실패하면 NULL을 반환

char *ptr;
ptr = malloc(sizeof(char) * 100));






2) calloc()
배열을 저장할 메모리할당

char *ptr;
ptr = calloc(10,20);

10 -> 배열의 요소
20 -> 각 요소의 크기가 20바이트인 배열을 저장할 수 있는 메모리 할당



3) realloc()

char *ptr, *new;
ptr = malloc(sizeof(char) * 100);
new = relloc(ptr, 100);

기존 ptr에 100바이트를 더 할당 받는다.




4) free()
메모리 해제

free(ptr);












(5) 명령행 인자
ls /tmp 명령어에서 ls는 명령어 /tmp는 명령어 인자이다.

main() 함수에서 명령어 인자를 전달 받으려면 다음과 같이 정의한다.

int main (int argc, char *argv[]){
}

argc는 명령어와 인자를 모두 포함한 개수이다.
argv[]는 명령어와 인자를 담고있는 배열이다.

#char *argv[]이고 const가 없기에 인자값으로 문자열 상수가 아닌 문자열 주소값을 받는다는 것을 유추할 수 있다.
-> char *argv[] = { a, b, c} ( O )
-> char *argv[] = { "HI", "bye", "good"} ( X )

###############################################################################################################################################################################
[root@localhost ~]# cat test.c
#include <stdio.h>

int main(int argc, char *argv[]) {
    int n;

    printf("argc = %d\n", argc);

    for (n = 0; n < argc; n++) {
        printf("%s ", argv[n]); // Add a space to separate arguments
    }

    printf("\n"); // Add a newline character to improve output formatting

    return 0; // Indicate a successful execution
}

[root@localhost ~]# ./a.out hi hi hi hi hi
argc = 6
./a.out hi hi hi hi hi

###############################################################################################################################################################################









getopt()함수로 옵션 처리
getopt의 3번째 인자 값에서 사용 가능 한 옵션이 -a, -b, -c 처럼 "문자 형태 만!"을 사용한다면 abc로 설정
-> getopt(argc, argv, "abc")

a에서 인자값을 불러오는 옵션이 있으면 ( 3중 하나라도) abc:로 인자값 설정
-> getopt(argc, argv, "abc:")
###############################################################################################################################################################################
[root@localhost ~]# cat test.c
#include <stdio.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    int opt;
    int a_flag = 0;
    char *b_arg = NULL;

    while ((opt = getopt(argc, argv, "ab:")) != -1) {
        switch (opt) {
            case 'a':
                a_flag = 1;
                break;
            case 'b':
                b_arg = optarg; // optarg에 현재 옵션에 대한 인수가 저장됨
			/*위의 예제에서 optarg 변수는 getopt() 함수를 호출할 때 자동으로 업데이트되고, 현재 처리 중인 옵션에 대한 인수를 가리킵니다. 
			이를 통해 옵션의 인수를 효과적으로 검색하고 처리할 수 있습니다.*/
                break;
        }
    }

    printf("a_flag = %d\n", a_flag);
    if (b_arg) {
        printf("b_arg = %s\n", b_arg);
    }

    return 0;
}

[root@localhost ~]# ./a.out -a -b hihihi
a_flag = 1
b_arg = hihihi
###############################################################################################################################################################################
