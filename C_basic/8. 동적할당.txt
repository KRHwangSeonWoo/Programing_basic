[동적 할당]

1. 동적할당의 개념
프로그램 수행 도중 할당되거나 해제되는 변수를 동적 할당 변수라고하고 프로그램 시작시 할당되어 프로그램 종료 시에 해제되는 변수를 정적 할당 변수라고 함, 동적 할당 변수를 간단히
동적 변수라고 하고, 정적 할당 변수를 정적 변수라고 함.

정적 변수 -> 전역 변수(함수 안에서 선언한 변수), 파일 범위 변수 (함수 밖에서 static으로 선언한 변수), static 지역 변수

동적 변수

자동변수 -> 비정적 지역변수, 매개변수
동적 할당 변수 -> 힙 할당 변수 


************메모리 구조*******************

메모리는 총 3개로 구별된다.

1. 코드 세그먼트: 코드와 리터널 상수 등이 저장됨.
2. 스택: 활성화된 함수의 영역이 저장됨 즉, 지역변수와 배개변수가 저장됨.
3. 힙: 자유저장공간 (동적 할당 변수)

************동적 할당의 필요성*****************
예를 들어 배열 선언 시 배열의 크기를 알 수 없으면, 어떤 값을 담을지 몰라 크게 선언하게 된다. -> 메모리 남용
그렇기에 필요한 만큼 메모리를 할당하자~ 이게 동적 할당이다.










2. 동적 할당의 활용


(1) 동적 할당, malloc과 free

void* malloc(size_t size) 함수로 동적으로 할당할 수 있다. 보이는 것처럼 void 포인터로 반환하는데 malloc으로 할당한 메모리가 가르키는 값을 참조하기 위해서는 
해당되는 포인터 형으로 변환시켜줘야 한다.

void free(void *p) 함수로 동적으로 할당한 메모리를 해제할 수 있다. 매개변수 자료형도 void* 인데 이때 형변환을 시켜주지 않아도 된다.
왜냐면 모든 포인터는 자동으로 void*로 형변환되기 때문이다.

malloc은 메모리 할당을 실패하면 0을 return한다.
############################################################################################################################################################################################################################################################################################################
#include<stdio.h>
#include<stdlib.h>

int main() {

    printf("생성할 int 배열의 개수를 입력하세요");

    int array_num;
    int num = scanf_s("%d", &array_num);

    printf("%p\n", (int*)malloc(num * sizeof(int)));
    // 0000019588AF3470
    //(int *)는 형변환 함수의 return과 같이 int *로 받을 수 있는 형태로 형변환하겠다는 뜻임.
    //즉 int 3개 12바이트를 힙에 할당하고, void *을 반환 (주소값)
    //그리고 int 형으로 메모리를 할당했으니깐 int *로 형변환
    //(int*) malloc(num * sizeof(int))은 주소값이 나옴


    int* ptr = (int*)malloc(array_num * sizeof(int));

    if (ptr == NULL) {
        printf("메모리 할당 실패\n");
        return 1;
    }

    //*(ptr + 1) = 1; 로도 사용가능
    ptr[1] = 1;
    //*ptr[1] = 1; -> 에러! -> 이형태는 포인터 배열일 때 사용! (*ptr[1] = &a... 이런식)

    /*
    ptr은 동적으로 할당된 메모리를 가리키는 포인터이며, ptr[1]은 두 번째 요소가 가르키는 값을 의미합니다 ([]는 이미 *의 의미를 내포)
    -> ptr[3]은 ptr의 시작 주소에서 12 바이트를 더한 주소가 가르키는 값 = *(ptr + 4)
    따라서, ptr[1]과 같이 배열처럼 사용할 때에는 역참조(*)를 하지 않습니다. -> *ptr[3]를 사용하게 되면 이중 포인터의 의미!

    [위 예제 상황]
    ptr[1] -> ptr의 주소에서 int 즉 4바이트 뒤의 주소가 가르키는 값!

    [아래 예제]
    *ptr[1] -> ptr[1]은 cd 변수의 시작 주소 + 4바이트를 가르키고 있고 해당 주소에 저장된 값(주소)가 가르키는 값 (참조연산) -> 포인터 배열 시 사용 (이중 포인터)
    */

    printf("할당된 메모리 블록의 주소: %p\n", ptr);
    printf("배열의 첫 번째 요소의 주소: %p\n", &ptr[0]);
    printf("배열의 첫 번째 요소의 값: %d\n", *(ptr + 1));

    /*
할당된 메모리 블록의 주소: 0000017EB634CDD0
배열의 첫 번째 요소의 주소: 0000017EB634CDD0
배열의 첫 번째 요소의 값: 1
    */

    //free(ptr); // 메모리 누수를 방지하기 위해 할당된 메모리를 해제합니다.
    //free((char*)ptr); -> 심지어 이것도 문제없이 메모리가 해제됨.
    free((void*)ptr); //-> 권장

    /*
정확히 말씀드리자면, C 언어 규격에서 free() 함수는 void 포인터를 인자로 받아야 합니다. 이것은 C 언어의 규격에 정의된 사항입니다. 
free() 함수가 void 포인터를 인자로 받는 이유는 메모리 할당 시점에 어떤 타입으로 할당되었는지에 대한 정보를 가지고 있지 않기 때문입니다. 
따라서, free() 함수가 어떤 타입의 포인터인지 알 수 없으며, void 포인터로 선언되어 있기 때문에 이를 받아들입니다.

하지만 C 컴파일러들은 일반적으로 free() 함수에 void 포인터 이외의 포인터를 전달해도 컴파일을 허용하고, 이를 "암시적 형변환(implicit type conversion)"을 수행합니다. 이러한 암시적 형변환은 컴파일러가 묵시적으로 타입을 변환하여 컴파일을 허용하는 기능을 말합니다.

따라서, 대부분의 C 컴파일러들은 free() 함수에 int 포인터와 같은 다른 포인터 타입도 암시적으로 void 포인터로 변환하여 받아들일 수 있습니다. 이는 대부분의 상황에서 문제가 없도록 설계되었습니다. 하지만 이러한 암시적 형변환은 언어의 규격에는 부합하지 않으며, 언제나 안전한 것은 아닙니다.

안전하고 명확한 코드를 작성하기 위해선, free() 함수에 void 포인터를 명시적으로 전달하는 것이 좋습니다. 즉, free((void *)arr);과 같이 명시적인 형변환을 수행하여 free() 함수에 void 포인터를 전달하는 것이 바람직합니다. 이렇게 함으로써 언어 규격을 따르고, 포인터의 타입 변환에 따른 잠재적인 문제를 방지할 수 있습니다.
    
    */
    


    //////////////////////////////////////////////////예제////////////////////////////////////////////////
    //포인터 배열의 예제! (int * ptr1[2] = &a; 이런식으로 사용해보자)
    int ab = 10;
    int cd = 20;
    int* ptr1[2] = { &ab, &cd };

    *ptr1[0] = 5; // ptr1[0]이 가리키는 메모리에 5를 할당
    //*(ptr1 + 1) = 56; 에러
    //ptr1[0] = 5; 에러

    printf("*(ptr1 + 1)의 값 : %p\n", *(ptr1 + 1));
    //*(ptr1 + 1)의 값 : 00000030766FF564, 연속해있는 것이 아니기에 정상적인 값이 나오지 않음
    //ab의 주소값에서 4바이트 뒤 위치의 값을 구한 것임

    printf("ab: %d\n", *ptr1[0]); // ab의 값 출력: 5
    printf("cd: %d\n", *ptr1[1]); // cd의 값 출력: 20 

    return 0;
}
############################################################################################################################################################################################################################################################################################################











(1) calloc, realloc 함수

1) calloc
malloc은 원하는 크기의 블록을 그냥 할당하는 함수이고, calloc은 배열에 특화된 함수이다.
malloc이랑 별 다른 건 없다.
int* arr = (int*)calloc(n, sizeof(int));
############################################################################################################################################################################################################################################################################################################
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    printf("할당할 정수의 개수를 입력하세요: ");
    scanf("%d", &n);

    // calloc 함수를 사용하여 n개의 int 크기의 메모리를 할당하고 모두 0으로 초기화합니다.
    int* arr = (int*)calloc(n, sizeof(int));

    if (arr == NULL) {
        printf("메모리 할당에 실패했습니다.\n");
        return 1;
    }

    printf("%d개의 정수를 입력하세요: ", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    printf("입력한 정수들: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // 동적으로 할당된 메모리를 반납합니다.
    free(arr);

    return 0;
}
############################################################################################################################################################################################################################################################################################################




2) realloc
새롭게 메모리를 할당한 곳에 기존의 포인터 변수의 "값" (주소값 X)을 그대로 옮기고 필요하면 더 메모리를 할당할 수 있다.
이후 기존 포인터 변수에 새롭게 만든 변수를 대입해줘야 한다. (안정성을 위해)

[정리]
int* arr = (int*)malloc(n * sizeof(int));
int* resized_arr = (int*)realloc(arr, (n + new_size) * sizeof(int));
arr = resized_arr;

or 

int* arr = (int*)malloc(n * sizeof(int));
arr = (int*)realloc(arr, (n + new_size) * sizeof(int));
############################################################################################################################################################################################################################################################################################################
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 3;

    // 동적으로 n개의 int 크기의 메모리를 할당합니다.
    int* arr = (int*)malloc(n * sizeof(int));

    if (arr == NULL) {
        printf("메모리 할당에 실패했습니다.\n");
        return 1;
    }

        arr[2] = 10;
        printf("%d\n", arr[2]);
        //10
        
        //아래 2줄이 정상적으로 실행되지만 버퍼 오버런이 발생한다.
        arr[4] = 5;
        printf("%d\n", arr[4]);
        //5
        /*
    버퍼 오버런은 보안 취약점으로 이용되는 경우가 많아서 심각한 문제가 될 수 있습니다. 일반적으로 다음과 같은 상황에서 발생할 수 있습니다:

    배열의 인덱스를 제대로 체크하지 않고 데이터를 쓰거나 읽는 경우.
    할당된 메모리의 크기보다 큰 범위에 데이터를 쓰거나 읽는 경우.
    함수의 인자로 전달된 배열에 대해 유효성 검사를 하지 않고 데이터를 쓰거나 읽는 경우.
    버퍼 오버런이 발생하면, 메모리의 영역을 침범하여 예상치 못한 결과가 발생하거나 시스템의 안정성이 저하될 수 있습니다.
    이러한 취약점은 악의적인 해커에게 악용될 수 있어서 데이터 유출이나 시스템의 무단 조작과 같은 보안 위협으로 이어질 수 있습니다.

        */
        int new_size = 2;

        // realloc 함수를 사용하여 배열의 크기를 늘립니다.
        int* resized_arr = (int*)realloc(arr, (n + new_size) * sizeof(int));

        if (resized_arr == NULL) {
            printf("메모리 재할당에 실패했습니다.\n");
            free(arr);
            return 1;
        }

        printf("%d\n", arr[2]);
        //10

        printf("resized_arr: %d\n", arr[2]);
        //10

        // 기존에 할당된 메모리 블록을 가리키는 포인터가 변경될 수 있으므로
        // 새로운 포인터로 교체해주어야 합니다.
        arr = resized_arr;

        arr[4] = 5;
        printf("%d\n", arr[2]);
        //10
        printf("%d\n",arr[4]);
        //5
        free(arr);

        return 0;




    }

############################################################################################################################################################################################################################################################################################################

############################################################################################################################################################################################################################################################################################################
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr = NULL; // 초기에는 배열을 할당하지 않음
    int n = 0; // 배열의 현재 크기
    int element;
    char choice;

    do {
        printf("정수를 입력하세요: ");
        scanf("%d", &element);

        // 배열을 더 크게 확장 (초기에는 메모리를 할당함)
        n++;
        arr = (int *)realloc(arr, n * sizeof(int));

        // 동적 할당이 실패했을 경우 NULL 검사
        if (arr == NULL) {
            printf("메모리 할당에 실패했습니다.");
            return 1; // 프로그램 종료
        }

        // 입력받은 값을 배열에 저장
        arr[n - 1] = element;

        printf("계속 입력하시겠습니까? (y/n): ");
        scanf(" %c", &choice); // 공백 문자를 추가하여 이전 엔터를 처리

    } while (choice == 'y' || choice == 'Y');

    // 배열 요소 출력
    printf("입력한 배열 요소:\n");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }

    // 동적으로 할당한 메모리 해제
    free(arr);

    return 0;
}
############################################################################################################################################################################################################################################################################################################






(2) assert 매크로 -> 이건 malloc에서 오류처리를 쉽게 하는 것이지(다른 것도 사용가능), 동적할당과는 관련 있지는 않다.

앞에 프로그램은 malloc 반환 값을 참고하여 오류처리를 수행했다. 그러나 실제로 malloc이 실패하는 것이 그렇게 쉽지가 않은데 따라서 매번 이 할당 받을 때 이 코드르 넣는 것이 번거로울 수 있다.
이때 assert()를 사용하면 편하게 가능하다.

***프로그램 내 특정지점에서 반드시 만족해야 할 전제조건을 검사할 경우에는 assert 매크로를 활용하면 편리함
컴파일 시 NDEBUG 옵션을 키면 assert 매크로는 무시됨.
#################################################################################################################################################
assert(수식); 은 안에 수식이 참이면 Assertion failed: [수식], file [파일 이름], line 26을 print해준다.

#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

int main() {
	
	int* p;
	p = (int*)malloc(3 * sizeof(int));

	assert(p == NULL);
	//Assertion failed : p == NULL, file C : \Users\pc - 1\source\repos\test\test\FileName.cpp, line 10


}
#################################################################################################################################################



























(3) 동적 배열
 -> 테스트상 오류가 발생한다. 일단 책에 있는 내용이니 참고만 하자.





1) 동적 배열의 개념
int n = 10;
int num_arr[n]; 같은 형태이다.
#################################################################################################################################################
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

int main() {
	int n;

	scanf_s("%d", &n);

	int num_arr[n];

}
#################################################################################################################################################








2) 동적 배열의 활용
동적 배열은 배열 크기가 함수 인수로 주어질 때 특히 편리하게 사용가능하다.
#################################################################################################################################################
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

//n을 인수로 구현부 안에서 int a[n] 배열 생성
int sum(int n) {
	int a[n];
}

//n을 인수로 매개변수 단에서 int n_arry[n] 생성
int sum_2(int n, int n_arry[n]) {
	
}

int main() {


}
#################################################################################################################################################







































3. 동적 할당과 스택
동적 할당은 컨테이너 구조를 구현할 때 사용되며, 컨테이너 구조란 다른 여러 데이터를 포함할 수 있는 데이터 구조를 뜻함




(1) 스택의 이해
스택은 후입 선출 구조의 컨테이너임.
스택에 자료를 여러 개 넣었다가 나중에 사용하려고 할 때 가장 나중에 넣은 것이 먼저 나오는 구조임.

*스택은 통산 네가지 연산과 함께 사용됨.
PUSH(s, d): 스택 s에 데이터 d를 넣음
POP(s): 스택 S의 최상위 데이터를 추출하여 반환함.
IS_EMPTY(s): 스택 s가 비어있는지 확인
IS_FULL(s): 스택 s가 꽉 찼는지 확인


#################################################################################################################################################
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

#define MAX_SIZE 10
/*
#define:이 헷가리면 전처리 지시자 및 표준 입출력.txt 참조
*/
struct stack {
	int data[MAX_SIZE];
	int top;

};

typedef struct stack Stack;

void error(const char* msg /*이부분이 헷갈리면 문자열.txt의 내용을 참조*/) {
	printf(msg);
	exit(-1);
}

int isEmpty(const Stack* s) {
	if (s->top == 0) {
		return 1;
	}
	else {
		return 0;
	}
}

int isFull(const Stack* s) {

	if (s->top == MAX_SIZE) {
		return 1;
	}
	else {
		return 0;
	}
}


//struct stack(구조체)의 포인터를 반환하는 함수
Stack * mkStack() {
	Stack* s = (Stack*)malloc(sizeof(Stack));
	
	//(*s).top = 0; 이렇게도 가능하지만 가독성을 위해서 아래처럼 사용하자.
	s->top = 0;
	return s;
	
}




void push(Stack* s, int item) {

	if (isFull(s)) {
		error("스택 공간이 모자람");
	}

	s->data[s->top++] = item;
	//s->top++은 로직을 처리하고 1을 더함
	
}

int pop(Stack* s) {
	if (isEmpty(s)) {
		error("스택이 비었음");
	}
	return s->data[--s->top];
	//--s->top 로직을 처리하기 전에 1을 뺀다. 즉 (s->top) - 1 과 같음
}



int main() {

	Stack* s;
	s = mkStack();

	int a = 0;
	printf("%d", a++);
	//0
	printf("%d", a++);
	//1


	push(s, 3);
	printf("%d",s->top);
	//1
	push(s, 4);
	push(s, 3);
	push(s, 3);
	push(s, 3);
	push(s, 3);
	push(s, 3);
	push(s, 3);
	push(s, 3);
	push(s, 9);
	//push(s,3);하면 error 함수가 실행됨.

	printf("%d",pop(s));
	//9 맨 마지막이 출력됨.


}
##################################################################################################################################################################################################################################################################################################



(2) 동적으로 배열을 이용하기 (위 예제는 data[10]으로 10개만 제한적으로 스택에 들어갈 수 있다. 무한으로 들어가게 하려면?)
int data[10]이 아닌, int* data를 사용하여 동적으로 메모리를 할당 받아 사용해보자!
##################################################################################################################################################################################################################################################################################################
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>


struct stack {
	int *data; //-> int *data로 해주자.
	int top;
	int size; //-> size를 추가해주자.

};

typedef struct stack Stack;

void error(const char* msg /*이부분이 헷갈리면 문자열.txt의 내용을 참조*/) {
	printf(msg);
	exit(-1);
}

int isEmpty(const Stack* s) {
	if (s->top == 0) {
		return 1;
	}
	else {
		return 0;
	}
}



//struct stack(구조체)의 포인터를 반환하는 함수
Stack * mkStack() {
	Stack* s = (Stack*)malloc(sizeof(Stack));
	//(*s).top = 0; 이렇게도 가능하지만 가독성을 위해서 아래처럼 사용하자.
	s->size = 1;
	s->top = 0;
	s->data = (int*)malloc(s->size * sizeof(int));

	return s;
	
}




void push(Stack* s, int item) {

	int* re_size = (int*)realloc(s->data, (1 + s->size) * sizeof(int));
	s->data[s->top++] = item;
	s->size++;
	//s->top++은 로직을 처리하고 1을 더함, s->size++;도 마찬가지
	s->data = re_size;

}



int pop(Stack* s) {
	if (isEmpty(s)) {
		error("스택이 비었음");
	}
	return s->data[--s->top];
	//--s->top 로직을 처리하기 전에 1을 뺀다. 즉 (s->top) - 1 과 같음
}



int main() {

	Stack* s;
	s = mkStack();

	push(s, 3);

	push(s, 4);
	push(s, 3);
	push(s, 3);
	push(s, 3);
	push(s, 3);
	push(s, 3);
	push(s, 3);
	push(s, 3);
	push(s, 9);
	push(s, 3);
	push(s, 30);
	//push(s,3);하면 error 함수가 실행됨.

	printf("%d\n",pop(s));
	//30 맨 마지막이 출력됨.


}
##################################################################################################################################################################################################################################################################################################











4. 큐의 이해(자기 참조 구조체를 이용한 이해) -> 어려우니 꼭 이해하고 넘어가자
만약 여러 학생들의 데이터를 저장하는 가장 간단한 방법은 구조체 배열을 이용하는 것인데 이 방법은 배열의 크기를 미리 정해야하는 문제점이 있다.
이 방법은 배열이 들어오면 크기를 미리정해야 하는 문제점이 있는데, 미리 정한 배열의 크기 보다 많은 학생이 들어오면 처리할 수 없고, 이보다 적은 학생의 데이터가 입력되면 미리할당된 기억공간이 낭비될 것이다.

여기서 자기참조 구조체를 사용하여 해결할 수 있다.
아래 예제는 큐이며, 선입선출 구조의 컨테이너이다.
##################################################################################################################################################################################################################################################################################################
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct student {
    int id;
    char name[20];
    struct student* next;
};

int main() {
    struct student* ptr, * head, * tail;
    head = tail = NULL;
    int con = 1;
    ptr = (struct student*)malloc(sizeof(struct student));

    while (con == 1) {
        ptr->next = NULL;
        printf("학생 정보를 입력해주세요: ");
        scanf_s("%d %19s", &ptr->id, ptr->name, sizeof(ptr->name));

        if (head == NULL) {
            head = ptr;
        }
        else {
            tail->next = ptr;
        }
        tail = ptr; 
        ptr = (struct student*)malloc(sizeof(struct student));

        printf("학생 정보를 입력하실건가요? 1 or any: ");
        scanf_s("%d", &con);
    }

    ptr = head;
    while (ptr != NULL) {
        printf("ID: %d, 이름: %s\n", ptr->id, ptr->name);
        ptr = ptr->next;
    }

    // 동적으로 할당된 메모리를 해제
    ptr = head;
    while (ptr != NULL) {
        struct student* next = ptr->next;
        free(ptr);
        ptr = next;
    }

    return 0;
}
##################################################################################################################################################################################################################################################################################################
